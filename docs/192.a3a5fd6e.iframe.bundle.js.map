{"version":3,"file":"192.a3a5fd6e.iframe.bundle.js","mappings":";;;;AAuEA;;;;ACjCA;;;;AC0EA;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;AAGA;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;ACzCA;;;;;AC3EA;;AAEA;;;AAGA;;;;;;;;;;;;;;;;;;;AAqBA;;;;;;;;;;;;;;;;;;;;;;;ACdA;;AC8EA;;AAEA;;;;AAIA;;AAEA;;;;;;;AAOA;;AAIA;;AC9FA;;;;;;AAQA;;;ACRA;;;;;AAKA;;;;;;;;;;;;;;;;;;AAkBA;;;;;AAOA;;;ACvBA;;;;AAIA;;;;AAMA;;;;;ACFA;;;AAGA;;;;;;;;;AASA;;;;;AAKA;;;;;;AAQA;;AC2FA;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AACA;;;;;;;;AAQA;;;;;;AAMA;;;;;;AAMA;AACA;AACA;AACA;;AAEA;AACA;;;;AAUA;;;ACvMA;;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;ACjCA;;;;ACFA;;;AAGA;;;AAGA;;;;;AAOA","sources":["webpack://sd-design/./src/components/grid/Col.ts","webpack://sd-design/./src/components/grid/Row.ts","webpack://sd-design/./src/components/input/ClearableLabeledWrapper.ts","webpack://sd-design/./src/components/input/Input.ts","webpack://sd-design/./src/components/input/Password.ts","webpack://sd-design/./src/components/input/TextArea.ts","webpack://sd-design/./src/components/input-number/InputNumber.ts","webpack://sd-design/./src/components/list/VirtualList.ts","webpack://sd-design/./src/components/list/List.ts","webpack://sd-design/./src/components/trigger/Trigger.ts","webpack://sd-design/./src/components/select/Overflow.ts","webpack://sd-design/./src/components/select/Select.ts","webpack://sd-design/./src/components/checkbox/Checkbox.ts","webpack://sd-design/./src/components/checkbox/Group.ts","webpack://sd-design/./src/components/switch/Switch.ts"],"sourcesContent":["import { Component, xml } from '@odoo/owl';\nimport { responsiveArray } from '@/components/_util/responsiveObserve';\nimport { getPrefixCls, stylesToString } from '@/components/_util/utils';\nimport classNames from 'classnames';\nimport Row from './Row';\nimport { baseProps, BaseProps } from '@/common/baseProps';\n\ntype ColSpanType = number | string;\n\ntype IColSize = {\n    span?: ColSpanType;\n    order?: ColSpanType;\n    offset?: ColSpanType;\n    push?: ColSpanType;\n    pull?: ColSpanType;\n};\n\ntype Props = {\n    className?: string;\n    span?: ColSpanType;\n    order?: ColSpanType;\n    offset?: ColSpanType;\n    push?: ColSpanType;\n    pull?: ColSpanType;\n    xs?: ColSpanType | IColSize;\n    sm?: ColSpanType | IColSize;\n    md?: ColSpanType | IColSize;\n    lg?: ColSpanType | IColSize;\n    xl?: ColSpanType | IColSize;\n    xxl?: ColSpanType | IColSize;\n    flex?: number | 'none' | 'auto' | string;\n} & BaseProps;\n\ntype Env = {\n    row: Row\n}\n\nconst parseFlex = (flex: number | 'none' | 'auto' | string): string => {\n    if (typeof flex === 'number') {\n        return `${flex} ${flex} auto`;\n    }\n    if (/^\\d+(\\.\\d+)?(px|em|rem|%)$/.test(flex)) {\n        return `0 0 ${flex}`;\n    }\n    return flex;\n};\n\nexport default class Col extends Component<Props, Env> {\n    static props = {\n        className: { type: String, optional: true },\n        span: { type: [Number, String], optional: true },\n        order: { type: [Number, String], optional: true },\n        offset: { type: [Number, String], optional: true },\n        push: { type: [Number, String], optional: true },\n        pull: { type: [Number, String], optional: true },\n        xs: { type: [Number, Object], optional: true },\n        sm: { type: [Number, Object], optional: true },\n        md: { type: [Number, Object], optional: true },\n        lg: { type: [Number, Object], optional: true },\n        xl: { type: [Number, Object], optional: true },\n        xxl: { type: [Number, Object], optional: true },\n        flex: { type: [Number, String], optional: true },\n        ...baseProps\n    };\n\n    static template = xml`\n    <div t-att-class=\"getClasses()\" t-att-style=\"getStyle()\">\n        <t t-slot=\"default\"/>\n    </div>\n    `;\n\n    protected getStyle(): string | undefined {\n        let colStyle: { [key: string]: any } = {};\n        if (this.props.flex) {\n            colStyle.flex = parseFlex(this.props.flex);\n        }\n        return stylesToString(colStyle) || undefined;\n    }\n\n    protected getClasses(): string {\n        const { span, order, offset, push, pull } = this.props;\n        const prefixCls = getPrefixCls('col');\n        let sizeClassObj = {};\n        // 组装响应式class类\n        responsiveArray.forEach((size) => {\n            let sizeProps: IColSize = {};\n            const propSize = this.props[size];\n            if (typeof propSize === 'number') {\n                sizeProps.span = propSize;\n            } else if (typeof propSize === 'object') {\n                sizeProps = propSize || {};\n            }\n            sizeClassObj = {\n                ...sizeClassObj,\n                [`${prefixCls}-${size}-${sizeProps.span}`]: sizeProps.span !== undefined,\n                [`${prefixCls}-${size}-order-${sizeProps.order}`]:\n                sizeProps.order || sizeProps.order === 0,\n                [`${prefixCls}-${size}-offset-${sizeProps.offset}`]:\n                sizeProps.offset || sizeProps.offset === 0,\n                [`${prefixCls}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,\n                [`${prefixCls}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0\n            };\n        });\n\n        return classNames(\n            prefixCls,\n            this.props.className,\n            {\n                [`${prefixCls}-${span}`]: span !== undefined,\n                [`${prefixCls}-order-${order}`]: order,\n                [`${prefixCls}-offset-${offset}`]: offset,\n                [`${prefixCls}-push-${push}`]: push,\n                [`${prefixCls}-pull-${pull}`]: pull\n            },\n            sizeClassObj\n        );\n    }\n}\n","import { Component, useChildSubEnv, useEffect, useState, xml } from '@odoo/owl';\nimport { Breakpoint, responsiveArray, responsiveObserve, ScreenMap } from '@/components/_util/responsiveObserve';\nimport classNames from 'classnames';\nimport { getPrefixCls, stylesToString } from '@/components/_util/utils';\nimport { baseProps, BaseProps } from '@/common/baseProps';\n\ntype State = {\n    className?: string;\n    style?: string;\n    screens: ScreenMap;\n};\n\ntype Gutter = number | Partial<Record<Breakpoint, number>>;\n\ntype Props = {\n    className?: string;\n    gutter?: Gutter | [Gutter, Gutter];\n    align?: 'top' | 'middle' | 'bottom';\n    justify?: 'start' | 'end' | 'center' | 'space-around' | 'space-between';\n    wrap?: boolean;\n} & BaseProps;\n\nexport default class Row extends Component<Props> {\n    static props = {\n        className: { type: String, optional: true },\n        gutter: { type: [Number, Array], optional: true },\n        align: { type: String, optional: true },\n        justify: { type: String, optional: true },\n        wrap: { type: Boolean, optional: true },\n        ...baseProps\n    };\n\n    static template: string = xml`\n        <div t-att-class=\"state.className\" t-att-style=\"state.style\">\n            <t t-slot=\"default\"/>\n        </div>\n    `;\n\n    state = useState<State>({\n        className: undefined,\n        style: undefined,\n        screens: {\n            xs: true,\n            sm: true,\n            md: true,\n            lg: true,\n            xl: true,\n            xxl: true\n        }\n    });\n\n    protected getGutter(screens: ScreenMap): [number, number] {\n        const results: [number, number] = [0, 0];\n        const { gutter = 0 } = this.props;\n        const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, 0];\n        normalizedGutter.forEach((g, index) => {\n            if (typeof g === 'object') {\n                for (let breakpoint of responsiveArray) {\n                    if (screens[breakpoint] && g[breakpoint] !== undefined) {\n                        results[index] = g[breakpoint] as number;\n                        break;\n                    }\n                }\n            } else {\n                results[index] = g || 0;\n            }\n        });\n        return results;\n    }\n\n    protected getStyle(screens: ScreenMap): Record<string, string> {\n        const gutter = this.getGutter(screens);\n\n        return {\n            ...(gutter[0] > 0\n                ? {\n                    'column-gap ': `${gutter[0]}px`\n                }\n                : {}),\n            ...(gutter[1] > 0\n                ? {\n                    'row-gap': `${gutter[1]}px`\n                }\n                : {})\n        };\n    }\n\n    protected getClasses(): string {\n        const { justify, align, wrap } = this.props;\n        const prefixCls = getPrefixCls('row');\n        return classNames(this.props.className, prefixCls, {\n            [`${prefixCls}-${justify}`]: justify,\n            [`${prefixCls}-${align}`]: align,\n            [`${prefixCls}-nowrap`]: wrap === false\n        });\n    }\n\n    setup(): void {\n        useChildSubEnv({ row: this });\n        useEffect(() => {\n            const token = responsiveObserve.subscribe((screens: ScreenMap) => {\n                const currentGutter = this.props.gutter || 0;\n                if (\n                    (!Array.isArray(currentGutter) && typeof currentGutter === 'object') ||\n                    (Array.isArray(currentGutter) &&\n                        (typeof currentGutter[0] === 'object' || typeof currentGutter[1] === 'object'))\n                ) {\n                    this.state.screens = screens;\n                }\n                this.state.style = stylesToString(this.getStyle(screens)) || undefined;\n                this.state.className = this.getClasses() || undefined;\n            });\n\n            return () => {\n                responsiveObserve.unsubscribe(token);\n            };\n        }, () => [this.props]);\n    }\n}\n","import { Component, useState, xml } from '@odoo/owl';\nimport { SizeType } from '@/components/_util/type';\nimport { getPrefixCls, getSDSVG } from '@/components/_util/utils';\nimport classNames from 'classnames';\nimport { getInputClassName } from '@/components/input/utils';\nimport _closeFillSVG from '@/assets/close_fill.svg';\nimport './style/clearable-labeled-wrapper.scss';\nimport { baseProps, BaseProps } from '@/common/baseProps';\n\nconst closeFillSVG = getSDSVG(_closeFillSVG, {\n    width: '1em',\n    height: '1em'\n});\n\n/** This basic props required for input and textarea. */\ntype IBasicProps = {\n    className?: string;\n    inputType: 'text' | 'input';\n    direction?: 'ltr' | 'rtl';\n    value?: any;\n    allowClear?: boolean;\n    disabled?: boolean;\n    focused?: boolean;\n    readOnly?: boolean;\n    bordered: boolean;\n    handleReset: (event: MouseEvent) => void;\n    count?: string;\n} & BaseProps;\n\n/** This props only for input. */\ntype IClearableWrapperProps = {\n    size?: SizeType;\n} & IBasicProps;\n\ntype State = {}\n\nconst showCountSpanClass = getPrefixCls('input-show-count-suffix');\n\nexport default class ClearableLabeledWrapper extends Component<IClearableWrapperProps> {\n\n    static props = {\n        className: { type: String, optional: true },\n        inputType: { type: String, optional: true },\n        direction: { type: String, optional: true },\n        value: { type: [String, Number], optional: true },\n        allowClear: { type: Boolean, optional: true },\n        disabled: { type: Boolean, optional: true },\n        focused: { type: Boolean, optional: true },\n        readOnly: { type: Boolean, optional: true },\n        bordered: { type: Boolean, optional: true },\n        handleReset: { type: Function, optional: true },\n        count: { type: String, optional: true },\n        size: { type: String, optional: true },\n        ...baseProps\n    }\n\n    /**\n     * 渲染清除按钮的模版\n     */\n    static clearTemplate: string = `\n        <t t-set=\"clearIconClass\" t-value=\"renderClearIconClass()\"/>\n        <span\n          role=\"button\"\n          aria-label=\"close-circle\"\n          tabIndex=\"-1\"\n          t-on-click.stop=\"props.handleReset\"\n          t-att-class=\"clearIconClass\"\n        >\n         ${closeFillSVG}\n        </span> \n    `;\n\n    /**\n     * 渲染带有前缀或者后缀的input的模版\n     */\n    static innerTemplate: string = `\n        <t t-if=\"!hasPrefixSuffix()\">\n            <t t-slot=\"default\"/>\n        </t>\n        <t t-else=\"\">\n            <t t-set=\"labeledIconClass\" t-value=\"renderLabeledIconClass()\"/>\n                        \n            <span t-att-class=\"labeledIconClass.affixWrapperCls\">\n                <!--  prefix插槽  -->\n                <t t-if=\"props.slots.prefix\">\n                    <span t-att-class=\"labeledIconClass.prefixClass\">\n                        <t t-slot=\"prefix\"/>\n                    </span>\n                </t>\n                \n                <t t-slot=\"default\" />\n                \n                <!--  suffix插槽  -->\n                <t t-if=\"props.slots.suffix || props.allowClear || props.count\">\n                    <span t-att-class=\"labeledIconClass.suffixClass\">\n                        <t t-if=\"props.allowClear\">\n                            ${ClearableLabeledWrapper.clearTemplate}\n                        </t>\n                        <t t-if=\"props.count\">\n                            <span class=\"${showCountSpanClass}\"><t t-esc=\"props.count\"/></span>\n                        </t>\n                        <t t-slot=\"suffix\"/>\n                    </span>\n                </t>\n            </span>\n        </t>\n    `;\n\n    static template: string = xml`\n        <t>\n            <t t-if=\"props.inputType === 'input'\">\n                <t t-if=\"!hasAddon()\">\n                    ${ClearableLabeledWrapper.innerTemplate}\n                </t>\n                \n                <t t-else=\"\">\n                    <t t-set=\"inputWithLabelClass\" t-value=\"renderInputWithLabelClass()\"/>\n                \n                    <span t-att-class=\"inputWithLabelClass.mergedGroupClassName\">\n                        <span t-att-class=\"inputWithLabelClass.mergedWrapperClassName\">\n                            <!--  addonBefore插槽  -->\n                            <t t-if=\"props.slots.addonBefore\">\n                                <span t-att-class=\"inputWithLabelClass.addonClassName\">\n                                    <t t-slot=\"addonBefore\"/>\n                                </span>\n                            </t>\n                            \n                            ${ClearableLabeledWrapper.innerTemplate}\n                            \n                            <!--  addonAfter插槽  -->\n                            <t t-if=\"props.slots.addonAfter\">\n                                <span t-att-class=\"inputWithLabelClass.addonClassName\">\n                                    <t t-slot=\"addonAfter\"/>\n                                </span>\n                            </t>\n                        </span>\n                    </span>\n                </t>\n            </t>\n            <t t-else=\"\">\n                <t t-if=\"!hasTextSuffix()\">\n                    <t t-slot=\"default\"/>\n                </t>\n                <t t-else=\"\">\n                    <t t-set=\"textAreaIconClass\" t-value=\"renderTextAreaWithClearIconClass()\"/>\n                    <span t-att-class=\"textAreaIconClass.affixWrapperCls\">\n                        <t t-slot=\"default\"/>\n                        \n                        <t t-set=\"labeledIconClass\" t-value=\"renderLabeledIconClass()\"/>\n                        <span t-att-class=\"labeledIconClass.suffixClass\">\n                            <t t-if=\"props.allowClear\">\n                                ${ClearableLabeledWrapper.clearTemplate}\n                            </t>\n                            <t t-if=\"props.count\">\n                                <span class=\"${showCountSpanClass}\"><t t-esc=\"props.count\"/></span>\n                            </t>\n                        </span>\n                    </span>\n                </t>\n            </t>\n        </t>\n    `;\n\n    static defaultProps = {\n        inputType: 'input',\n        bordered: true\n    };\n\n    state = useState<State>({});\n\n    protected hasTextSuffix(): boolean {\n        return !!this.props.allowClear || !!this.props.count\n    }\n\n    /**\n     * 判断是否有前置、后置部分\n     */\n    protected hasAddon(): boolean {\n        const { slots } = this.props;\n        return !!(slots?.addonBefore || slots?.addonAfter);\n    }\n\n    /**\n     * 判断是否有前缀、后缀\n     */\n    protected hasPrefixSuffix(): boolean {\n        const { slots } = this.props;\n        return !!(slots?.prefix || slots?.suffix || this.props.allowClear || !!this.props.count);\n    }\n\n    /**\n     * 清除图标的class\n     */\n    protected renderClearIconClass(): string | undefined {\n        const { value, allowClear, disabled, readOnly, slots } = this.props;\n        if (!allowClear) {\n            return;\n        }\n        const needClear = !disabled && !readOnly && value;\n        const prefixCls = getPrefixCls('input');\n        const className = `${prefixCls}-clear-icon`;\n        return classNames(\n            {\n                [`${className}-hidden`]: !needClear,\n                [`${className}-has-suffix`]: !!slots?.suffix\n            },\n            className\n        );\n    }\n\n    /**\n     * innerTemplate主区域部分的class\n     */\n    protected renderLabeledIconClass(): {} {\n        const {\n            focused,\n            value,\n            size,\n            disabled,\n            allowClear,\n            direction,\n            readOnly,\n            bordered,\n            slots\n        } = this.props;\n\n        const prefixCls = getPrefixCls('input');\n\n        const suffixClass = `${prefixCls}-suffix`;\n\n        const prefixClass = `${prefixCls}-prefix`;\n\n        const affixWrapperCls = classNames(`${prefixCls}-affix-wrapper`, {\n            [`${prefixCls}-affix-wrapper-focused`]: focused,\n            [`${prefixCls}-affix-wrapper-disabled`]: disabled,\n            [`${prefixCls}-affix-wrapper-sm`]: size === 'small',\n            [`${prefixCls}-affix-wrapper-lg`]: size === 'large',\n            [`${prefixCls}-affix-wrapper-input-with-clear-btn`]: allowClear && value,\n            [`${prefixCls}-affix-wrapper-rtl`]: direction === 'rtl',\n            [`${prefixCls}-affix-wrapper-readonly`]: readOnly,\n            [`${prefixCls}-affix-wrapper-borderless`]: !bordered\n        });\n\n        const classes = getInputClassName(prefixCls, bordered, size, disabled);\n\n        return { affixWrapperCls, prefixClass, suffixClass, classes };\n    }\n\n    /**\n     * 外部区域的class\n     */\n    protected renderInputWithLabelClass(): {} {\n        const { size, className, direction } = this.props;\n        const prefixCls = getPrefixCls('input');\n        const wrapperClassName = `${prefixCls}-group`;\n        const addonClassName = `${wrapperClassName}-addon`;\n\n        const mergedWrapperClassName = classNames(`${prefixCls}-wrapper`, wrapperClassName, {\n            [`${wrapperClassName}-rtl`]: direction === 'rtl'\n        });\n\n        const mergedGroupClassName = classNames(\n            `${prefixCls}-group-wrapper`,\n            {\n                [`${prefixCls}-group-wrapper-sm`]: size === 'small',\n                [`${prefixCls}-group-wrapper-lg`]: size === 'large',\n                [`${prefixCls}-group-wrapper-rtl`]: direction === 'rtl'\n            },\n            className\n        );\n\n        return { addonClassName, mergedWrapperClassName, mergedGroupClassName };\n    }\n\n    /**\n     * 文本域带有清除按钮的class\n     */\n    protected renderTextAreaWithClearIconClass(): {} {\n        const { bordered, direction, disabled, allowClear, value } = this.props;\n        const prefixCls = getPrefixCls('input');\n\n        const affixWrapperCls = classNames(\n            `${prefixCls}-affix-wrapper`,\n            `${prefixCls}-affix-wrapper-textarea`,\n            {\n                [`${prefixCls}-affix-wrapper-textarea-with-clear-btn`]: allowClear && value,\n                [`${prefixCls}-affix-wrapper-disabled`]: disabled,\n                [`${prefixCls}-affix-wrapper-rtl`]: direction === 'rtl',\n                [`${prefixCls}-affix-wrapper-borderless`]: !bordered\n            }\n        );\n\n        return { affixWrapperCls };\n    }\n}\n","import { Component, useEffect, useRef, useState, xml } from '@odoo/owl';\nimport ClearableLabeledWrapper from './ClearableLabeledWrapper';\nimport { getPrefixCls, omit } from '@/components/_util/utils';\nimport classNames from 'classnames';\nimport { getInputClassName } from '@/components/input/utils';\nimport { SizeType } from '@/components/_util/type';\nimport './style/input.scss';\nimport useControllableState from '@/hooks/useControllableState';\nimport { useImperativeHandle } from '@/hooks/useImperativeHandle';\nimport { baseProps, BaseProps } from '@/common/baseProps';\n\nexport interface IInputFocusOptions extends FocusOptions {\n    cursor?: 'start' | 'end' | 'all';\n}\n\nexport function triggerFocus(\n    element?: HTMLInputElement | HTMLTextAreaElement | null,\n    option?: IInputFocusOptions\n): void {\n    if (!element) {\n        return;\n    }\n\n    element.focus(option);\n\n    // Selection content\n    const { cursor } = option || {};\n    if (cursor) {\n        const len = element.value.length;\n\n        switch (cursor) {\n            case 'start':\n                element.setSelectionRange(0, 0);\n                break;\n\n            case 'end':\n                element.setSelectionRange(len, len);\n                break;\n\n            default:\n                element.setSelectionRange(0, len);\n        }\n    }\n}\n\nexport type InputProps = {\n    className?: string,\n    size?: SizeType,\n    disabled?: boolean,\n    type?: string,  // input自有type\n    maxLength?: number,\n    allowClear?: boolean;\n    bordered?: boolean;\n    placeholder?: string;\n    showCount?: boolean;\n    defaultValue?: any;\n    value?: any;\n    onFocus?: (event: any) => void;\n    onBlur?: (event: any) => void;\n    onChange?: (value: string) => void;\n    onInput?: (event: any) => void;\n    onPressEnter?: (event: any) => void;\n    onKeyDown?: (event: any) => void;\n} & BaseProps;\n\ntype State = {\n    focused: boolean;\n    count?: string;\n    restProps: Record<string, any>\n}\n\nexport default class Input<T extends InputProps> extends Component<T> {\n    static props = {\n        className: { type: String, optional: true },\n        size: { type: String, optional: true },\n        disabled: { type: Boolean, optional: true },\n        type: { type: String, optional: true },\n        maxLength: { type: Number, optional: true },\n        allowClear: { type: Boolean, optional: true },\n        bordered: { type: Boolean, optional: true },\n        placeholder: { type: String, optional: true },\n        showCount: { type: Boolean, optional: true },\n        defaultValue: { type: String, optional: true },\n        value: { type: String, optional: true },\n        onFocus: { type: Function, optional: true },\n        onBlur: { type: Function, optional: true },\n        onChange: { type: Function, optional: true },\n        onInput: { type: Function, optional: true },\n        onPressEnter: { type: Function, optional: true },\n        onKeyDown: { type: Function, optional: true },\n        readonly: { type: Boolean, optional: true },\n        ...baseProps\n    };\n\n    static components = { ClearableLabeledWrapper };\n\n    static template = xml`\n<ClearableLabeledWrapper className=\"props.className\" inputType=\"'input'\" bordered=\"props.bordered\" size=\"props.size\"\n    disabled=\"props.disabled\" focused=\"state.focused\" allowClear=\"props.allowClear\" value=\"controllableState.state.value\"\n    handleReset.alike=\"(e) => this.handleReset(e)\" slots=\"props.slots\" count=\"state.count\"\n>\n    <input \n        t-att=\"state.restProps\"\n        t-att-disabled=\"props.disabled\"\n        t-att-maxlength=\"props.maxLength\"\n        t-att-type=\"props.type\"\n        t-att-placeholder=\"props.placeholder\"\n        t-att-class=\"getClasses()\"\n        t-on-focus=\"onFocus\"\n        t-on-blur=\"onBlur\"\n        t-ref=\"input\"\n        t-on-keydown.stop=\"handleKeyDown\"\n        t-on-compositionstart=\"onCompositionstart\"\n        t-on-compositionend=\"onCompositionend\"\n        t-on-input=\"onInput\"\n        t-on-change=\"onChange\"\n    />\n</ClearableLabeledWrapper>\n`;\n\n    inputRef: { el: HTMLInputElement | null } = { el: null };\n\n    static defaultProps = {\n        type: 'text',\n        bordered: true\n    };\n\n    // 区分当前是中文输入还是英文输入的flag\n    compositionFlag = false;\n\n    state = useState<State>({\n        focused: false,\n        count: undefined,\n        restProps: {}\n    });\n\n    controllableState = useControllableState(this.props, {\n        value: this.props.defaultValue ?? ''\n    });\n\n    protected getClasses(): string {\n        const { size, disabled, bordered } = this.props;\n        const prefixCls = getPrefixCls('input');\n        return classNames(getInputClassName(prefixCls, bordered, size, disabled));\n    }\n\n    protected focus(): void {\n        triggerFocus(this.inputRef.el);\n        this.state.focused = true;\n    }\n\n    protected onFocus(event: FocusEvent): void {\n        const { onFocus } = this.props;\n        this.state.focused = true;\n        onFocus?.(event);\n    }\n\n    protected blur(): void {\n        this.inputRef.el!.blur();\n        this.state.focused = false;\n    }\n\n    protected onBlur(event: FocusEvent): void {\n        const { onBlur } = this.props;\n        this.state.focused = false;\n        onBlur?.(event);\n    }\n\n    protected handleKeyDown(e: KeyboardEvent) {\n        const { onPressEnter, onKeyDown } = this.props;\n        if (onPressEnter && e.key.toLowerCase() === 'enter') {\n            onPressEnter(e);\n        }\n        onKeyDown?.(e);\n    };\n\n    protected onCompositionstart() {\n        this.compositionFlag = true;\n    };\n\n    protected onCompositionend(e: Event) {\n        this.compositionFlag = false;\n        this.onInput(e);\n    };\n\n    protected changeValue(value: string) {\n        this.controllableState.setState({ value });\n        this.inputRef.el!.value = this.controllableState.state.value;\n        this.props.onInput?.(value);\n        this.props.onChange?.(value);\n    };\n\n    protected onChange(e: Event) {\n        const value = (e.target as HTMLInputElement).value;\n        this.props.onChange?.(value);\n    }\n\n    protected onInput(e: Event) {\n        if (this.compositionFlag) {\n            return;\n        }\n\n        // 设置input的value\n        const value = (e.target as HTMLInputElement).value;\n        this.changeValue(value);\n    };\n\n    /**\n     * 清除输入框\n     */\n    protected handleReset(): void {\n        this.changeValue('');\n        triggerFocus(this.inputRef.el);\n    };\n\n    protected getRestProps() {\n        return omit(this.props, [\n            'className',\n            'size',\n            'disabled',\n            'type',\n            'maxLength',\n            'allowClear',\n            'bordered',\n            'placeholder',\n            'showCount',\n            'defaultValue',\n            'value',\n            'onFocus',\n            'onBlur',\n            'onChange',\n            'onPressEnter',\n            'onKeyDown',\n            'slots'\n        ]);\n    }\n\n    setup(): void {\n        this.inputRef = useRef('input');\n\n        useImperativeHandle(() => ({\n            focus: this.focus.bind(this),\n            blur: this.blur.bind(this)\n        }), () => []);\n\n        useEffect(() => {\n            this.state.restProps = this.getRestProps();\n        }, () => [this.props]);\n\n        useEffect(() => {\n            if (this.inputRef.el) {\n                this.inputRef.el!.value = this.controllableState.state.value;\n            }\n        }, () => [this.inputRef.el]);\n\n        useEffect(() => {\n            this.inputRef.el!.value = this.controllableState.state.value;\n            if (this.props.showCount) {\n                const value = this.controllableState.state.value;\n                this.state.count = this.props.maxLength ? `${value.length}/${this.props.maxLength}` : `${value.length}`;\n            } else {\n                this.state.count = undefined;\n            }\n        }, () => [this.props.showCount, this.controllableState.state.value]);\n    }\n}\n","import { useEffect, useState, xml } from '@odoo/owl';\nimport Input, { InputProps } from './Input';\nimport _eyeSVG from '@/assets/eye.svg';\nimport _eyeCloseSVG from '@/assets/eye-close.svg';\nimport { getPrefixCls, getSDSVG, omit } from '@/components/_util/utils';\nimport classNames from 'classnames';\nimport './style/password.scss';\nimport useControllableState from '@/hooks/useControllableState';\n\nconst eyeSVG = getSDSVG(_eyeSVG, {\n    width: '1em',\n    height: '1em'\n});\n\nconst eyeCloseSVG = getSDSVG(_eyeCloseSVG, {\n    width: '1em',\n    height: '1em'\n});\n\nexport type PasswordProps = InputProps & {\n    visible?: boolean;\n    onVisibleChange?: (visible: boolean) => void;\n}\n\ntype State = {\n    focused: boolean;\n    value: any;\n    type: string;\n    restProps: {}\n}\n\nconst passwordClass = getPrefixCls('input-password');\n\nexport default class Password extends Input<PasswordProps> {\n    static props = {\n        ...Input.props,\n        visible: { type: Boolean, optional: true },\n        onVisibleChange: { type: Function, optional: true }\n    }\n\n    static template = xml`\n <ClearableLabeledWrapper className=\"props.className\" inputType=\"'input'\" bordered=\"props.bordered\" size=\"props.size\"\n    disabled=\"props.disabled\" focused=\"state.focused\" allowClear=\"props.allowClear\" value=\"state.value\"\n    handleReset.alike=\"(e) => this.handleReset(e)\" slots=\"props.slots\">\n    <t t-set-slot=\"suffix\">\n        <div t-on-click=\"togglePasswordVisibility\" class=\"${passwordClass}-suffix\">\n            <t t-if=\"controllableState.state.visible\">\n                ${eyeCloseSVG}\n            </t>\n            <t t-else=\"\">\n                ${eyeSVG}\n            </t>\n        </div>\n    </t>\n    \n    <input \n        t-att=\"state.restProps\"\n        t-att-disabled=\"props.disabled\"\n        t-att-maxlength=\"props.maxLength\"\n        t-att-type=\"state.type\"\n        t-att-placeholder=\"props.placeholder\"\n        t-att-class=\"getClasses()\"\n        t-on-focus.stop=\"onFocus\"\n        t-on-blur.stop=\"onBlur\"\n        t-ref=\"input\"\n        t-on-keydown.stop=\"handleKeyDown\"\n        t-model=\"state.value\"\n    />\n </ClearableLabeledWrapper>   \n    `;\n\n    state = useState<State>({\n        focused: false,\n        value: '',\n        type: 'password',\n        restProps: {}\n    });\n\n    controllableState = useControllableState(this.props, {\n        visible: false,\n        value: this.props.defaultValue || ''\n    });\n\n    protected getClasses(): string {\n        return classNames(super.getClasses(), passwordClass);\n    }\n\n    protected togglePasswordVisibility(): void {\n        if (!this.props.disabled) {\n            this.controllableState.setState({\n                visible: !this.controllableState.state.visible\n            });\n            this.props.onVisibleChange?.(!this.controllableState.state.visible);\n        }\n    }\n\n    protected getRestProps() {\n        return omit(super.getRestProps(), ['visible', 'onVisibleChange']);\n    }\n\n    public setup(): void {\n        super.setup();\n        useEffect(() => {\n            this.state.type = this.controllableState.state.visible ? 'text' : 'password';\n        }, () => [this.controllableState.state.visible]);\n    }\n}\n","import Input, { InputProps } from './Input';\nimport { useEffect, useState, xml } from '@odoo/owl';\nimport './style/textarea.scss';\nimport classNames from 'classnames';\nimport { getPrefixCls, omit, stylesToString } from '@/components/_util/utils';\nimport { calculateAutoSizeHeight } from '@/components/input/_utils/calculateNodeHeight';\n\ntype State = {\n    style?: string\n}\n\ntype AutoSize = boolean | {\n    minRows: number\n    maxRows: number\n}\n\nexport type TextAreaProps = Omit<InputProps & {\n    rows?: number;\n    autoSize?: AutoSize;\n    onResize?: (size: { width: number, height: number }) => void;\n}, 'slots'>\n\nconst textareaClass = getPrefixCls('input-textarea');\n\nexport default class TextArea extends Input<TextAreaProps> {\n    static props = {\n        ...Input.props,\n        rows: { type: Number, optional: true },\n        autoSize: { type: [Boolean, Object], optional: true },\n        onResize: { type: Function, optional: true }\n    };\n\n    static template = xml`\n<ClearableLabeledWrapper className=\"props.className\" inputType=\"'text'\" bordered=\"props.bordered\" size=\"props.size\"\n    disabled=\"props.disabled\" focused=\"state.focused\" allowClear=\"props.allowClear\" value=\"controllableState.state.value\"\n    handleReset.alike=\"(e) => this.handleReset(e)\" count=\"state.count\"\n>\n    <textarea\n            t-att-style=\"textState.style\"\n            t-att=\"state.restProps\"\n            t-att-disabled=\"props.disabled\"\n            t-att-maxlength=\"props.maxLength\"\n            t-att-type=\"props.type\"\n            t-att-placeholder=\"props.placeholder\"\n            t-att-class=\"getClasses()\"\n            t-on-focus.stop=\"onFocus\"\n            t-on-blur.stop=\"onBlur\"\n            t-ref=\"input\"\n            t-on-keydown.stop=\"handleKeyDown\"\n            t-on-compositionstart=\"onCompositionstart\"\n            t-on-compositionend=\"onCompositionend\"\n            t-on-input=\"onInput\"\n            t-on-change=\"onChange\"\n        />\n</ClearableLabeledWrapper>\n`;\n\n    textState = useState<State>({\n        style: undefined\n    });\n\n    protected getClasses(): string {\n        return classNames(super.getClasses(), textareaClass, {\n            [`${textareaClass}-autosize`]: this.props.autoSize\n        });\n    }\n\n    protected getRestProps() {\n        return omit(super.getRestProps(), ['autoSize', 'onResize']);\n    }\n\n    protected resizeRows() {\n        if (!this.props.autoSize) {\n            this.textState.style = undefined;\n            return;\n        }\n\n        let maxRows = 2;\n        let minRows = 2;\n        const el = this.inputRef.el!;\n        const style = window.getComputedStyle(el);\n        const attrs = ['padding-top', 'padding-bottom'];\n        const [paddingTop, paddingBottom] = attrs.map(item => style.getPropertyValue(item));\n        const lineHeight = parseFloat(style.getPropertyValue('line-height'));\n        const rowsHeight = calculateAutoSizeHeight(el as unknown as HTMLTextAreaElement) - parseFloat(\n            paddingTop) - parseFloat(paddingBottom);\n        const rows = Math.ceil(rowsHeight / lineHeight);\n\n        if (this.props.autoSize === true) {\n            maxRows = Math.max(rows, maxRows);  // 随自身内容高度变化\n        } else if (typeof this.props.autoSize === 'object') {\n            minRows = this.props.autoSize.minRows;\n            maxRows = this.props.autoSize.maxRows;\n        }\n        const realRows = Math.min(Math.max(rows, minRows), maxRows);\n        this.textState.style = stylesToString({\n            'height': `${realRows * lineHeight + parseFloat(paddingTop) + parseFloat(paddingBottom)}px`\n        });\n    }\n\n    protected changeValue(value: string) {\n        super.changeValue(value);\n        if (this.props.autoSize) {\n            this.resizeRows();\n        } else {\n            this.textState.style = undefined;\n        }\n    }\n\n    setup(): void {\n        super.setup();\n        useEffect(() => {\n            if (this.inputRef.el) {\n                const element = this.inputRef.el;\n                const resizeObserver = new ResizeObserver((entries) => {\n                    const contentBoxSize = entries?.[0].borderBoxSize?.[0];\n                    if (contentBoxSize) {\n                        this.props.onResize?.({ width: contentBoxSize.inlineSize, height: contentBoxSize.blockSize });\n                    }\n                });\n                resizeObserver.observe(element);\n\n                return () => {\n                    resizeObserver.unobserve(element);\n                };\n            }\n        }, () => [this.inputRef.el]);\n\n        useEffect(() => {\n            if (this.props.autoSize && this.inputRef.el) {\n                this.resizeRows();\n            }\n        }, () => [this.props.autoSize, this.inputRef.el, this.props.size]);\n    }\n}\n","import { Component, useEffect, useState, xml } from '@odoo/owl';\nimport Input from '@/components/input/Input';\nimport _upSVG from '@/assets/up.svg';\nimport _downSVG from '@/assets/down.svg';\nimport { getPrefixCls, getSDSVG, omit } from '@/components/_util/utils';\nimport './style/input-number.scss';\nimport classNames from 'classnames';\nimport { CompRef, useImperativeHandle } from '@/hooks/useImperativeHandle';\nimport useControllableState from '@/hooks/useControllableState';\nimport BigNumber from 'bignumber.js';\nimport { BaseProps, baseProps } from '@/common/baseProps';\nimport { SizeType } from '@/components/_util/type';\n\nconst inputNumberWrapClass = getPrefixCls('input-number-wrap');\nconst inputNumberClass = getPrefixCls('input-number');\nconst iconClass = getPrefixCls('input-number-icon');\nconst numberHandlerWrapClass = getPrefixCls('input-number-handler-wrap');\n\nconst upSVG = getSDSVG(_upSVG, {\n    width: '1em',\n    height: '1em'\n});\n\nconst downSVG = getSDSVG(_downSVG, {\n    width: '1em',\n    height: '1em'\n});\n\ntype Props = {\n    className?: string;\n    step?: number;\n    defaultValue?: number;\n    value?: number;\n    size?: SizeType;\n    onFocus?: (event: FocusEvent) => void;\n    onBlur?: (event: FocusEvent) => void;\n    onChange?: (value: number | string) => void;\n    max?: number;\n    min?: number;\n    placeholder?: string;\n    disabled?: boolean;\n    bordered?: boolean;\n    autoFocus?: boolean;\n    changeOnBlur?: boolean;\n    controls?: boolean;\n    decimalSeparator?: string;\n    precision?: number;\n    formatter?: (value: string) => string;\n    parser?: (value: string) => string;\n    keyboard?: boolean;\n    readonly?: boolean;\n    stringMode?: boolean;\n    onPressEnter?: (event: Event) => void;\n    onStep?: (value: number, info: { offset: number; type: 'up' | 'down' }) => void;\n} & BaseProps;\n\ntype State = {\n    focused: boolean;\n}\n\nclass InputNumber extends Component<Props, State> {\n    static props = {\n        className: { type: String, optional: true },\n        step: { type: Number, optional: true },\n        defaultValue: { type: Number, optional: true },\n        value: { type: Number, optional: true },\n        size: { type: String, optional: true },\n        onFocus: { type: Function, optional: true },\n        onBlur: { type: Function, optional: true },\n        onChange: { type: Function, optional: true },\n        max: { type: Number, optional: true },\n        min: { type: Number, optional: true },\n        placeholder: { type: String, optional: true },\n        disabled: { type: Boolean, optional: true },\n        bordered: { type: Boolean, optional: true },\n        autoFocus: { type: Boolean, optional: true },\n        changeOnBlur: { type: Boolean, optional: true },\n        controls: { type: Boolean, optional: true },\n        decimalSeparator: { type: String, optional: true },\n        precision: { type: Number, optional: true },\n        formatter: { type: Function, optional: true },\n        parser: { type: Function, optional: true },\n        keyboard: { type: Boolean, optional: true },\n        readonly: { type: Boolean, optional: true },\n        stringMode: { type: Boolean, optional: true },\n        onPressEnter: { type: Function, optional: true },\n        onStep: { type: Function, optional: true },\n        ...baseProps\n    };\n\n    static defaultProps = {\n        autoFocus: false,\n        changeOnBlur: true,\n        controls: true,\n        keyboard: true,\n        step: 1,\n        max: Number.MAX_SAFE_INTEGER,\n        min: Number.MIN_SAFE_INTEGER\n    };\n\n    static components = { Input };\n\n    static inputTemplate = `\n<span t-att-class=\"getClasses()\">\n    <Input className=\"\" ref=\"inputRef\" onFocus.bind=\"onFocus\" onBlur.bind=\"onBlur\" \n        onKeyDown.bind=\"onKeyDown\"\n        placeholder=\"props.placeholder\"\n        readonly=\"props.readonly\"\n        onPressEnter=\"props.onPressEnter\"\n        value=\"controllableState.state.value\" onChange.bind=\"onchangeValue\"\n        disabled=\"props.disabled\"\n        size=\"props.size\"\n        bordered=\"false\"\n        slots=\"filterSlots('ix')\"\n    />\n    <t t-if=\"showControls()\">\n        <t t-set=\"iconClass\" t-value=\"renderIconClasses()\"/>\n        <span class=\"${numberHandlerWrapClass}\" t-ref=\"handlerRef\" t-on-click=\"onClickWrap\">\n            <span t-att-class=\"iconClass.increase\" t-on-click=\"(event) => this.onStep('up', event)\">\n                <t t-slot=\"upIcon\">\n                    ${upSVG}\n                </t>\n            </span>\n            <span t-att-class=\"iconClass.decrease\" t-on-click=\"(event) => this.onStep('down', event)\">\n                <t t-slot=\"downIcon\">\n                    ${downSVG}\n                </t>\n            </span>\n        </span>\n    </t>    \n</span>\n`;\n\n    static template = xml`\n<t t-if=\"hasAddon()\">\n    <span class=\"${inputNumberWrapClass}\">\n        <t t-if=\"props.slots.addonBefore\">\n            <span class=\"${inputNumberWrapClass}-addon ${inputNumberClass}-addon-before\">\n                <t t-slot=\"addonBefore\"/>\n            </span>\n        </t>\n        ${InputNumber.inputTemplate}\n        <t t-if=\"props.slots.addonAfter\">\n            <span class=\"${inputNumberWrapClass}-addon ${inputNumberClass}-prefix\">\n                <t t-slot=\"addonAfter\"/>\n            </span>\n        </t>\n    </span>\n</t>\n<t t-else=\"\">\n    ${InputNumber.inputTemplate}\n</t>\n    `;\n\n    state = useState<State>({\n        focused: false\n    });\n\n    controllableState = useControllableState(this.props, {\n        value: this.props.defaultValue ? this.precisionValue(BigNumber(this.props.defaultValue)) : ''\n    }, (val) => `${val}`);\n\n    inputRef: CompRef = { current: undefined };\n\n    /**\n     * 判断是否有前置、后置部分\n     */\n    protected hasAddon(): boolean {\n        const { slots } = this.props;\n        return !!(slots?.addonBefore || slots?.addonAfter);\n    }\n\n    /**\n     * 过滤掉slots\n     * @param type 如果是addon，则过滤掉suffix、prefix，如果是ix，则过滤掉addonBefore、addonAfter\n     * @protected\n     */\n    protected filterSlots(type: 'addon' | 'ix') {\n        if (this.props.slots) {\n            return omit(this.props.slots, type === 'addon' ? ['suffix', 'prefix'] : ['addonBefore', 'addonAfter']);\n        }\n    }\n\n    /**\n     * 是否显示加减按钮\n     * @protected\n     */\n    protected showControls(): boolean {\n        return !!this.props.controls && !this.props.disabled;\n    }\n\n    protected focus(): void {\n        this.state.focused = true;\n    }\n\n    /**\n     * 获取焦点回调\n     * @param event\n     * @protected\n     */\n    protected onFocus(event: FocusEvent): void {\n        this.focus();\n        const { onFocus } = this.props;\n        onFocus?.(event);\n    }\n\n    protected blur(): void {\n        const { changeOnBlur } = this.props;\n        this.state.focused = false;\n        if (changeOnBlur) {\n            this.onchangeValue(this.getValueNotOutOfRange(this.controllableState.state.value));\n        }\n    }\n\n    /**\n     * 失去焦点回调，如果changeOnBlur为true，则在失去焦点时触发onChange\n     * @param event\n     * @protected\n     */\n    protected onBlur(event: FocusEvent): void {\n        this.blur();\n        const { onBlur, changeOnBlur } = this.props;\n        onBlur?.(event);\n    }\n\n    /**\n     * 键盘按下回调，如果keyboard为true，则可以使用上下键控制数字增减\n     * @param event\n     * @protected\n     */\n    protected onKeyDown(event: KeyboardEvent): void {\n        const { keyboard } = this.props;\n        if (keyboard) {\n            switch (event.key.toLowerCase()) {\n                case 'arrowup':\n                    event.preventDefault();\n                    this.increaseOrDecrease(true, event);\n                    break;\n                case 'arrowdown':\n                    event.preventDefault();\n                    this.increaseOrDecrease(false, event);\n                    break;\n            }\n        }\n    }\n\n    /**\n     * 点击加减按钮回调\n     * @param type up为加，down为减\n     * @param event\n     * @protected\n     */\n    protected onStep(type: 'up' | 'down', event: Event): void {\n        const { onStep } = this.props;\n        const oldValue = this.controllableState.state.value;\n        this.increaseOrDecrease(type === 'up', event);\n        onStep?.(Number(oldValue), { offset: this.props.step as number, type });\n    }\n\n    /**\n     * 点击外层wrap回调，聚焦input\n     * @protected\n     */\n    protected onClickWrap(): void {\n        this.inputRef.current?.focus();\n    }\n\n    /**\n     * 精确数字小数点并返回对应的字符串\n     * @param bn 值的BigNumber实例\n     * @protected\n     */\n    protected precisionValue(bn: BigNumber): string {\n        const { precision } = this.props;\n        return precision ? bn.toFixed(precision) : bn.toFixed();\n    }\n\n    /**\n     * 输入框值改变回调\n     * @param value\n     * @protected\n     */\n    protected onchangeValue(value: string): void {\n        const { stringMode } = this.props;\n        let stringValue = value;\n        if (value !== '') {\n            let bn = BigNumber(this.parse(value));\n            bn = bn.isNaN() ? BigNumber('0') : bn;\n            stringValue = this.precisionValue(bn);\n        }\n\n        this.controllableState.setState({\n            value: this.formatValue(stringValue)\n        });\n        this.props.onChange?.(stringMode ? stringValue : Number(stringValue));\n    }\n\n    /**\n     * 获取不超出范围的值，根据value值和max、min值判断\n     * @param value\n     * @protected\n     */\n    protected getValueNotOutOfRange(value: string): string {\n        if (value === '') {\n            return '';\n        }\n\n        const { max, min } = this.props;\n        let bn = BigNumber(value);\n        const v = bn.isNaN() ? BigNumber('0') : bn;\n        if (v.isNaN() || v.isGreaterThan(max!)) {\n            return max!.toString();\n        }\n        if (v.isNaN() || v.isLessThan(min!)) {\n            return min!.toString();\n        }\n        return v.toFixed();\n    }\n\n    /**\n     * 是否允许增加或减少\n     * @param isIncrease 加true，减false\n     * @protected\n     */\n    protected enableIncreaseOrDecrease(isIncrease: boolean): boolean {\n        const { min, max } = this.props;\n        const { value } = this.controllableState.state;\n        const bn = BigNumber(value || '0');\n\n        if (isIncrease && max !== undefined) {\n            return bn.isLessThan(max);\n        }\n        if (!isIncrease && min !== undefined) {\n            return bn.isGreaterThan(min);\n        }\n        return true;\n    }\n\n    /**\n     * 增加或减少value值\n     * @param isIncrease 加true，减false\n     * @param event\n     * @protected\n     */\n    protected increaseOrDecrease(isIncrease: boolean, event: Event): void {\n        event?.stopPropagation();\n        event?.preventDefault();\n        if (!this.enableIncreaseOrDecrease(isIncrease)) {\n            return;\n        }\n\n        const { step } = this.props;\n        const { value } = this.controllableState.state;\n        const bn = BigNumber(value || '0');\n        const newValue = isIncrease ? bn.plus(step as number) : bn.minus(step as number);\n        this.onchangeValue(this.getValueNotOutOfRange(newValue.toFixed()));\n    }\n\n    protected getClasses() {\n        return classNames(inputNumberClass, this.props.className, {\n            [`${inputNumberClass}-focused`]: this.state.focused,\n            [`${inputNumberClass}-disabled`]: !!this.props.disabled,\n            [`${inputNumberClass}-borderless`]: this.props.bordered === false\n        });\n    }\n\n    protected renderIconClasses() {\n        return {\n            increase: classNames(iconClass, {\n                [`${iconClass}-disabled`]: !this.enableIncreaseOrDecrease(true)\n            }),\n            decrease: classNames(iconClass, {\n                [`${iconClass}-disabled`]: !this.enableIncreaseOrDecrease(false)\n            })\n        };\n    }\n\n    /**\n     * 格式化value值，如果有formatter，则使用formatter格式化\n     * @param value\n     * @protected\n     */\n    protected formatValue(value: string): string {\n        const { decimalSeparator, formatter } = this.props;\n        if (decimalSeparator) {\n            // 替换.为decimalSeparator\n            value = value.replace(/\\./g, decimalSeparator);\n        }\n        if (formatter) {\n            value = formatter(value);\n        }\n\n        return value;\n    }\n\n    /**\n     * 解析value值，如果有parser，则使用parser解析\n     * @param value\n     * @protected\n     */\n    protected parse(value: string): string {\n        const { decimalSeparator, parser } = this.props;\n        if (decimalSeparator) {\n            // 替换decimalSeparator为. decimalSeparator可能为.或者其他\n            value = value.replace(new RegExp(decimalSeparator.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'g'), '.');\n        }\n        if (parser) {\n            value = parser(value);\n        }\n        return value;\n    }\n\n    setup(): void {\n        useImperativeHandle(() => ({\n            focus: this.focus.bind(this),\n            blur: this.blur.bind(this)\n        }), () => []);\n\n        useEffect(() => {\n            if (this.props.autoFocus) {\n                this.inputRef.current?.focus();\n            }\n        }, () => [this.inputRef.current]);\n    }\n}\n\nexport default InputNumber;\n","import { Component, useEffect, useRef, useState, xml } from '@odoo/owl';\nimport { useSize } from '@/hooks/useSize';\nimport { isNumber } from '@/components/_util';\nimport { getPrefixCls, stylesToString } from '@/components/_util/utils';\nimport { useEventListener } from '@/hooks/useEventListener';\nimport { useImperativeHandle } from '@/hooks/useImperativeHandle';\nimport { baseProps, BaseProps } from '@/common/baseProps';\nimport { MouseEvent } from 'react';\nimport classNames from 'classnames';\n\nexport type ItemHeight = (index: number, data: any) => number;\n\nexport type Position = 'start' | 'end' | 'mid';\n\nexport type OnRender = () => void;\n\ntype Props = {\n    className?: string,\n    list: any[],\n    height?: number,\n    itemHeight: number | ItemHeight,\n    overscan?: number,\n    onScroll?: (event: MouseEvent, position: Position) => void,\n    onRendered?: OnRender\n} & BaseProps;\n\ntype TargetData = {\n    index: number,\n    data: any\n}\n\ntype State = {\n    renderTriggerByEffect: boolean,\n    scrollTriggerByScrollToFunc: boolean,\n    targetList: TargetData[],\n    wrapperStyle?: string,\n    containerHeight: number\n}\n\nconst VirtualListClass = getPrefixCls('vir-list');\nconst VirtualListWrapperClass = getPrefixCls('vir-list-wrapper');\n\nclass VirtualList extends Component<Props> {\n    static props = {\n        className: { type: String, optional: true },\n        list: { type: Array },\n        height: { type: Number, optional: true },\n        itemHeight: { type: [Number, Function] },\n        overscan: { type: Number, optional: true },\n        onScroll: { type: Function, optional: true },\n        onRendered: { type: Function, optional: true },\n        ...baseProps\n    };\n\n    static defaultProps = {\n        overscan: 5\n    };\n\n    static template = xml`\n<div t-att-class=\"getClass()\" t-ref=\"container\" t-att-style=\"getStyle()\">\n    <div t-ref=\"wrapper\" t-att-style=\"state.wrapperStyle\" class=\"${VirtualListWrapperClass}\">\n        <t t-foreach=\"state.targetList\" t-as=\"target\" t-key=\"target.index\">\n            <t t-slot=\"item\" data=\"target.data\" index=\"target.index\" style=\"target.style\"/>\n        </t>\n    </div>\n</div>   \n    `;\n\n    containerRef = useRef<HTMLDivElement>('container');\n    wrapperRef = useRef<HTMLDivElement>('wrapper');\n    size = useSize('container');\n\n    state = useState<State>({\n        renderTriggerByEffect: false,\n        scrollTriggerByScrollToFunc: false,\n        targetList: [],\n        wrapperStyle: undefined,\n        containerHeight: 0\n    });\n\n    protected getClass() {\n        return classNames(VirtualListClass, this.props.className);\n    }\n\n    protected getStyle() {\n        const { height } = this.props;\n        const style = {\n            overflow: 'auto',\n            'overflow-anchor': 'none'\n        };\n        // 如果有指定高度，则设置max-height，否则height设为100%\n        // max-height可以达到在不需要滚动时，高度自适应的效果\n        if (isNumber(height)) {\n            style['max-height'] = `${height}px`;\n        } else {\n            style['height'] = '100%';\n        }\n        return stylesToString(style);\n    }\n\n    protected getTotalHeight() {\n        const { itemHeight } = this.props;\n        if (isNumber(itemHeight)) {\n            // 如果是固定高度，则直接计算\n            return this.props.list.length * itemHeight;\n        }\n        let sum = 0;\n        for (let i = 0; i < this.props.list.length; i++) {\n            const item = this.props.list[i];\n            const height = itemHeight(i, item);\n            sum += height;\n        }\n        return sum;\n    }\n\n    /**\n     * 获取当前的数据偏移量，注：指向的下一个数据索引\n     * @param scrollTop 滚动条距离顶部的距离\n     * @protected\n     */\n    protected getOffset(scrollTop: number): number {\n        const { itemHeight } = this.props;\n        if (isNumber(itemHeight)) {\n            // 如果是固定高度，则直接计算\n            return Math.ceil(scrollTop / itemHeight);\n        }\n\n        let sum = 0;\n        let offset = 0;\n        for (let i = 0; i < this.props.list.length; i++) {\n            const item = this.props.list[i];\n            const height = itemHeight(i, item);\n            sum += height;\n            if (sum >= scrollTop) {\n                offset = i;\n                break;\n            }\n        }\n        return offset + 1;\n    }\n\n    /**\n     * 获取可视区域内的数据数量\n     * @param clientHeight\n     * @param fromIndex\n     * @protected\n     */\n    protected getVisibleCount(clientHeight: number, fromIndex: number): number {\n        const { itemHeight } = this.props;\n        if (isNumber(itemHeight)) {\n            // 如果是固定高度，则直接计算\n            return Math.ceil(clientHeight / itemHeight);\n        }\n        let sum = 0;\n        let endIndex = 0;\n        for (let i = fromIndex; i < this.props.list.length; i++) {\n            const item = this.props.list[i];\n            const height = itemHeight(i, item);\n            sum += height;\n            endIndex = i;\n            if (sum >= clientHeight) {\n                break;\n            }\n        }\n        return endIndex - fromIndex;\n    }\n\n    /**\n     * 计算指定索引的数据距离顶部的距离\n     * @param index\n     * @protected\n     */\n    protected getDistanceTop(index: number): number {\n        const { itemHeight } = this.props;\n        if (isNumber(itemHeight)) {\n            // 如果是固定高度，则直接计算\n            return index * itemHeight;\n        }\n        let sum = 0;\n        for (let i = 0; i < index; i++) {\n            const item = this.props.list[i];\n            const height = itemHeight(i, item);\n            sum += height;\n        }\n        return sum;\n    }\n\n    /**\n     * 计算可视区域内的数据\n     * @protected\n     */\n    protected calculateRange() {\n        const { overscan, itemHeight } = this.props;\n        const container = this.containerRef.el;\n        if (container) {\n            const { scrollTop, clientHeight } = container;\n            const offset = this.getOffset(scrollTop);\n            const visibleCount = this.getVisibleCount(clientHeight, offset);\n            const start = Math.max(0, offset - overscan!);\n            const end = Math.min(this.props.list.length, offset + visibleCount + overscan!);\n            const offsetTop = this.getDistanceTop(start);\n            const totalHeight = this.getTotalHeight();\n            this.state.containerHeight = clientHeight;\n            this.state.wrapperStyle = stylesToString({\n                height: `${totalHeight - offsetTop}px`,\n                'margin-top': `${offsetTop}px`\n            });\n            this.state.targetList = this.props.list.slice(start, end).map((data, index) => ({\n                index: start + index,\n                data,\n                style: stylesToString({\n                    height: isNumber(itemHeight) ? `${itemHeight}px` : `${itemHeight(start + index, data)}px`\n                })\n            }));\n        }\n    }\n\n    protected scrollTo(index: number) {\n        if (this.containerRef.el) {\n            this.state.scrollTriggerByScrollToFunc = true;\n            this.containerRef.el.scrollTop = this.getDistanceTop(index);\n            this.calculateRange();\n        }\n    };\n\n    public setup(): void {\n        useImperativeHandle(() => ({\n            scrollTo: this.scrollTo.bind(this)\n        }), () => [this.props]);\n\n        useEventListener(this.containerRef, 'scroll', (event: MouseEvent) => {\n            if (this.state.scrollTriggerByScrollToFunc) {\n                // 如果是 scrollTo 方法触发的滚动，则不再触发计算\n                this.state.scrollTriggerByScrollToFunc = false;\n                return;\n            }\n            event.preventDefault();\n            this.calculateRange();\n            let position: Position = 'mid';\n            if (event.currentTarget.scrollTop === 0) {\n                position = 'start';\n            } else if (event.currentTarget.scrollHeight - event.currentTarget.scrollTop === this.state.containerHeight) {\n                // 可滚动总高度 - 滚动条距离顶部的距离 和 容器高度相等表示滚动到底部\n                position = 'end';\n            }\n\n            this.props.onScroll?.(event, position);\n        });\n\n        useEffect(() => {\n            if (this.state.renderTriggerByEffect) {\n                // 仅在受effect触发时才触发onRendered\n                this.props.onRendered?.();\n            }\n            this.state.renderTriggerByEffect = false;\n\n        }, () => [this.state.targetList]);\n\n        useEffect(() => {\n            this.state.renderTriggerByEffect = true;\n            this.calculateRange();\n        }, () => [this.size.width, this.size.height, this.props.list]);\n    }\n}\n\nexport default VirtualList;\n","import { Component, useState, xml } from '@odoo/owl';\nimport VirtualList, { ItemHeight, OnRender, Position } from '@/components/list/VirtualList';\nimport classNames from 'classnames';\nimport _emptySVG from '@/assets/empty.svg';\nimport { getPrefixCls, getSDSVG } from '@/components/_util/utils';\nimport { baseProps, BaseProps } from '@/common/baseProps';\nimport './style/list.scss';\nimport { SizeType } from '@/components/_util/type';\nimport { useCompRef, useImperativeHandle } from '@/hooks/useImperativeHandle';\n\nconst emptySVG = getSDSVG(_emptySVG, {\n    width: '64',\n    height: '41'\n});\n\ntype Props = {\n    size?: SizeType,\n    bordered?: boolean, // 是否有边框\n    className?: string, // 类名\n    itemClassName?: (item: any, index: number) => string, // 每一项的类名\n    dataSource: any[], // 数据源\n    virtual?: boolean, // 是否开启虚拟列表\n    height?: number, // virtual为true时设置，列表的高度，如果不设置则为container高度的100%\n    itemHeight?: number | ItemHeight, // virtual为true时设置，每一项的高度\n    onScroll?: (event: MouseEvent, position: Position) => void // virtual为true时设置，滚动时触发\n    onRendered?: OnRender // virtual为true时设置，渲染完成时触发\n} & BaseProps;\n\nconst listClass = getPrefixCls('list');\nconst listHeadClass = getPrefixCls('list-head');\nconst listContainerClass = getPrefixCls('list-container');\nconst listFooterClass = getPrefixCls('list-footer');\nconst listItemClass = getPrefixCls('list-item');\nconst vrListItemClass = getPrefixCls('vr-list-item');\n\nclass List extends Component<Props> {\n    static components = { VirtualList };\n\n    static props = {\n        className: { type: String, optional: true },\n        itemClassName: { type: Function, optional: true },\n        bordered: { type: Boolean, optional: true },\n        size: { type: String, optional: true },\n        dataSource: { type: Array, optional: true },\n        virtual: { type: Boolean, optional: true },\n        height: { type: Number, optional: true },\n        itemHeight: { type: [Number, Function], optional: true },\n        onScroll: { type: Function, optional: true },\n        onRendered: { type: Function, optional: true },\n        ...baseProps\n    };\n\n    static defaultProps = {\n        dataSource: [],\n        bordered: false\n    };\n\n    static template = xml`\n<div t-att-class=\"getClasses()\">\n    <t t-if=\"hasHeader()\">\n        <div class=\"${listHeadClass}\">\n            <t t-slot=\"header\"/>\n        </div>\n    </t>\n    \n    <div class=\"${listContainerClass}\">\n        <t t-if=\"showItems()\">\n            <t t-if=\"props.virtual\">\n                <VirtualList ref=\"virRef\" onScroll=\"props.onScroll\" onRendered=\"props.onRendered\" list=\"props.dataSource\" itemHeight=\"props.itemHeight\" height=\"props.height\">\n                    <t t-set-slot=\"item\" t-slot-scope=\"scope\">\n                        <div t-att-class=\"getItemClasses(scope.data, scope.index)\" t-att-style=\"scope.style\">\n                            <t t-slot=\"item\" t-props=\"scope\"/>\n                        </div>\n                    </t>\n                </VirtualList>\n            </t>\n            <div t-else=\"\" t-att-class=\"getItemClasses(item, item_index)\" t-foreach=\"props.dataSource\" t-as=\"item\" t-key=\"item_index\">\n                <t t-slot=\"item\" data=\"item\" index=\"item_index\"/>\n            </div>\n        </t>\n    </div>\n    \n    <t t-if=\"hasFooter()\">\n        <div class=\"${listFooterClass}\">\n            <t t-slot=\"footer\"/>\n        </div>\n    </t>\n</div>   \n    `;\n\n    state = useState({});\n    virRef = useCompRef();\n\n    protected hasHeader() {\n        return !!this.props.slots?.header;\n    }\n\n    protected hasFooter() {\n        return !!this.props.slots?.footer;\n    }\n\n    protected showItems() {\n        return !!this.props.slots?.item;\n    }\n\n    protected getClasses() {\n        const { className, bordered, size, virtual } = this.props;\n        const hasAnySlot = this.hasFooter() || this.hasHeader() || this.showItems();\n\n        return classNames(className, listClass, {\n            [`${listClass}-borderless`]: !bordered || !hasAnySlot,\n            [`${listClass}-sm`]: size === 'small',\n            [`${listClass}-lg`]: size === 'large',\n            [`${listClass}-vt`]: !!virtual\n        });\n    }\n\n    protected getItemClasses(item: any, index: number) {\n        return classNames(listItemClass, this.props.itemClassName?.(item, index), {\n            [vrListItemClass]: !!this.props.virtual\n        });\n    }\n\n    public setup(): void {\n        useImperativeHandle(() => ({\n            scrollTo: (index: number) => this.virRef.current?.scrollTo(index)\n        }), () => []);\n    }\n}\n\nexport default List;\n","import { Component, useEffect, useRef, useState, xml } from '@odoo/owl';\nimport { getPrefixCls, stylesToString } from '@/components/_util/utils';\nimport { baseProps, BaseProps } from '@/common/baseProps';\nimport classNames from 'classnames';\nimport domAlign from 'dom-align';\nimport './style/trigger.scss';\nimport { useImperativeHandle } from '@/hooks/useImperativeHandle';\nimport { useEventListener } from '@/hooks/useEventListener';\n\nexport type Placement = 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';\n\ntype Props = {\n    placement: Placement\n    className?: string;\n    isOpen: boolean;  // 是否显示\n    destroyOnHide?: boolean;  // 隐藏时销毁\n    triggerNode?: HTMLElement;  // 触发节点\n    getPopupContainer?: (triggerNode?: HTMLElement) => string; // 返回一个选择器字符串\n    getStyle?: (triggerNode?: HTMLElement) => string; // 返回一个样式字符串\n    onScroll?: (event: MouseEvent) => void;\n} & BaseProps;\n\nconst triggerClass = getPrefixCls('trigger');\nconst triggerHiddenClass = getPrefixCls('trigger-hidden');\n\n// 用第二个参数的位置去对齐第一个参数的位置\nconst placementMap: Record<Placement, [string, string]> = {\n    topLeft: ['bl', 'tl'],\n    topRight: ['br', 'tr'],\n    bottomLeft: ['tl', 'bl'],\n    bottomRight: ['tr', 'br']\n};\n\n// 第一个参数是sourceNode的x轴偏移量，第二个参数是sourceNode的y轴偏移量\nconst placementOffsetMap: Record<Placement, [number, number]> = {\n    topLeft: [0, -4],\n    topRight: [0, -4],\n    bottomLeft: [0, 4],\n    bottomRight: [0, 4]\n};\n\nclass Trigger extends Component<Props> {\n    static props = {\n        className: { type: String, optional: true },\n        placement: { type: String },\n        isOpen: { type: Boolean },\n        destroyOnHide: { type: Boolean, optional: true },\n        triggerNode: { type: Object, optional: true },\n        getPopupContainer: { type: Function, optional: true },\n        getStyle: { type: Function, optional: true },\n        onScroll: { type: Function, optional: true },\n        ...baseProps\n    };\n\n    static defaultProps = {\n        destroyOnHide: true\n    };\n\n    static contentTemplate = `\n<div t-ref=\"wrapperRef\" t-att-class=\"getClass()\" t-portal=\"getPopupContainer()\" t-att-style=\"getStyle()\">\n    <t t-slot=\"default\"/>\n</div>  \n    `;\n\n    static template = xml`\n<t>\n    <t t-if=\"!props.destroyOnHide\">\n        ${Trigger.contentTemplate}\n    </t>\n    <t t-else=\"\">\n        <t t-if=\"state.isShow\">\n            ${Trigger.contentTemplate}\n        </t>\n    </t>\n</t>\n    `;\n\n    wrapperRef = useRef('wrapperRef');\n\n    state = useState({\n        isShow: false // 用于控制隐藏时销毁\n    });\n\n    lastIsOpen = false;  // 最后一次是打开还是关闭，用来控制是否需要展示fade动画，因为第一次打开始终需要展示动画\n\n    protected getClass() {\n        const { className, isOpen } = this.props;\n        const notShowFade = isOpen && this.lastIsOpen;\n        return classNames(triggerClass, className, {\n            [`${triggerClass}-${isOpen ? 'fadein' : 'fadeout'}`]: !notShowFade\n        });\n    }\n\n    protected getPopupContainer(): string {\n        return this.props.getPopupContainer?.(this.props.triggerNode) || 'body';\n    }\n\n    protected getStyle() {\n        // 初始状态强制设置为隐藏\n        if (!this.props.triggerNode) {\n            return stylesToString({\n                'display': 'none'\n            });\n        }\n        return this.props.getStyle?.(this.props.triggerNode) || undefined;\n    }\n\n    /**\n     * 对齐\n     * @protected\n     */\n    protected align() {\n        const { triggerNode, placement } = this.props;\n        if (this.wrapperRef.el && triggerNode) {\n            const alignConfig = {\n                points: placementMap[placement],\n                offset: placementOffsetMap[placement],\n                targetOffset: ['0', '0'] // 同offset，不过是针对targetNode的\n            };\n            domAlign(this.wrapperRef.el, triggerNode, alignConfig);\n        }\n    }\n\n    public setup(): void {\n        useImperativeHandle(() => ({\n            wrapperRef: this.wrapperRef,\n            align: this.align.bind(this)\n        }), () => []);\n\n        useEventListener(this.wrapperRef, 'animationend', (event) => {\n            // 动画完成后添加hiddenclass，使不占据dom空间\n            if (event.animationName === 'fadeout') {\n                this.wrapperRef.el?.classList.add(triggerHiddenClass);\n                // 如果设置了隐藏时销毁，在动画完成后移除dom\n                if (this.props.destroyOnHide) {\n                    this.state.isShow = false;\n                }\n            }\n        });\n\n        useEventListener(this.wrapperRef, 'scroll', (event) => {\n            this.props.onScroll?.(event);\n        });\n\n        useEffect(() => {\n            const { isOpen } = this.props;\n            if (isOpen) {\n                this.state.isShow = true;\n            }\n        }, () => [this.props.isOpen]);\n\n        useEffect(() => {\n            const { isOpen } = this.props;\n            this.lastIsOpen = isOpen;\n            if (isOpen) {\n                // 打开时先移除hidden的class，否则display: none不能触发动画\n                this.wrapperRef.el?.classList.remove(triggerHiddenClass);\n            }\n            this.align();\n        }, () => [this.wrapperRef.el, this.props.isOpen, this.props.triggerNode]);\n    }\n}\n\nexport default Trigger;\n","import { Component, useEffect, useRef, useState, xml } from '@odoo/owl';\nimport { BaseProps, baseProps } from '@/common/baseProps';\nimport classNames from 'classnames';\nimport { getPrefixCls, getSDSVG } from '@/components/_util/utils';\nimport './style/overflow.scss';\nimport { useSize } from '@/hooks/useSize';\nimport _closeSVG from '@/assets/close.svg';\nimport { isNumber } from '@/components/_util';\n\nconst closeSVG = getSDSVG(_closeSVG, {\n    width: '1em',\n    height: '1em'\n});\n\ntype Props = {\n    className?: string;\n    values: (string | number)[];\n    options: Option[];\n    maxTagCount?: number | 'responsive';\n    handleDelete?: (option: Option) => void;\n} & BaseProps;\n\nconst overflowClass = getPrefixCls('overflow');\nconst displayTagClass = `${overflowClass}-display-span-tag`;\n\nexport type Option = {\n    value: string | number;\n    label: string\n}\n\ntype State = {\n    displayMaxIndex: number;\n    displayOptions: Option[];  // 用于显示的option，不会包含overflow部分\n    rest?: number;\n};\n\nclass Overflow extends Component<Props> {\n    static props = {\n        className: { type: String, optional: true },\n        values: { type: Array },\n        options: { type: Array },\n        maxTagCount: { type: [Number, String], optional: true },\n        handleDelete: { type: Function, optional: true },\n        ...baseProps\n    };\n\n    static tagTemplate = (inner: string) => `\n<span t-att-class=\"classes.rest\">\n    <span class=\"${displayTagClass}-container\">\n        <span class=\"${displayTagClass}-label\">\n            ${inner}\n        </span>\n    </span>\n</span>\n`;\n\n    static displayTemplate = (hasEvent: boolean) => `\n<t t-slot=\"tag\" data=\"option\">\n    <span class=\"${displayTagClass}\">\n        <span class=\"${displayTagClass}-container\">\n            <span class=\"${displayTagClass}-label\">\n                <t t-esc=\"option.label\"/>\n            </span>\n            <span class=\"${displayTagClass}-icon\" ${hasEvent ?\n        't-on-click.stop=\"(event) => this.handleDelete(option)\"' : ''} >${closeSVG}</span>\n        </span>\n    </span>\n</t>\n`;\n\n    static template = xml`\n<t>\n    <t t-set=\"classes\" t-value=\"getClass()\"/>\n    <span t-ref=\"container\" t-att-class=\"classes.container\">\n        <t t-foreach=\"state.displayOptions\" t-as=\"option\" t-key=\"option.value\">\n            ${Overflow.displayTemplate(true)}\n        </t> \n        <t t-if=\"state.rest\" >\n            ${Overflow.tagTemplate(`<t t-esc=\"'+' + state.rest + '...'\"/>`)}\n        </t>\n        <span t-att-class=\"classes.suffix\" t-ref=\"suffix\">\n            <t t-slot=\"suffix\"/>\n        </span>\n        \n        <t t-if=\"props.maxTagCount !== undefined\">\n            <span t-ref=\"temp\" t-att-class=\"classes.temp\">\n                <t t-foreach=\"getWholeOptions()\" t-as=\"option\" t-key=\"option.value\">\n                    ${Overflow.displayTemplate(false)}\n                </t> \n            </span>\n            <span t-ref=\"overFlowTemp\" t-att-class=\"classes.temp\">\n                <t t-foreach=\"props.values\" t-as=\"value\" t-key=\"value_index\">\n                    ${Overflow.tagTemplate(`<t t-esc=\"'+' + (value_index + 1) + '...'\"/>`)}\n                </t> \n            </span>\n        </t>\n    </span>\n</t>\n`;\n\n    containerRef = useRef('container');\n\n    tempRef = useRef('temp');\n\n    overFlowTempRef = useRef('overFlowTemp');\n\n    containerSize = useSize('container');\n\n    suffixSize = useSize('suffix');\n\n    state = useState<State>({\n        displayMaxIndex: 0,  // 超出显示时用于显示的索引\n        displayOptions: [],  // 超出显示时用于显示的值\n        rest: undefined\n    });\n\n    protected getClass() {\n        return {\n            container: classNames(this.props.className, overflowClass, {\n                [`${overflowClass}-responsive`]: this.props.maxTagCount === 'responsive'\n            }),\n            temp: classNames(this.props.className, `${overflowClass}-temp`),\n            rest: classNames(displayTagClass, `${overflowClass}-rest`),\n            suffix: `${overflowClass}-suffix`\n        };\n    }\n\n    protected isOverflow(index: number, targetWidth: number, searchWidth: number): boolean {\n        const restIndex = Math.max(0, this.props.values.length - 1 - index);\n        const overFlowSpamWidth = this.overFlowTempRef.el?.children[restIndex].getBoundingClientRect().width || 0;\n        return targetWidth + overFlowSpamWidth + searchWidth >= this.containerSize.width!;\n    }\n\n    protected handleDelete(option: Option) {\n        this.props.handleDelete?.(option);\n    }\n\n    /**\n     * 所有应该显示的option，包含overflow部分\n     * @protected\n     */\n    protected getWholeOptions() {\n        const { values, options } = this.props;\n        return options.filter((c) => values.indexOf(c.value) !== -1);\n    }\n\n    public setup(): void {\n        useEffect(() => {\n            const { maxTagCount, values, options } = this.props;\n            if (isNumber(maxTagCount)) {\n                this.state.displayMaxIndex = maxTagCount;\n            } else if (maxTagCount === undefined) {\n                this.state.displayMaxIndex = Math.max(0, this.props.values.length);\n            } else if (this.tempRef.el && this.containerSize.width) {\n                // 获取所有子元素\n                const children = this.tempRef.el.children;\n                // 初始化总宽度\n                let totalWidth = 0;\n                this.state.displayMaxIndex = values.length;\n                for (let i = 0; i < values.length; i++) {\n                    // 获取子元素的宽度，不包括间隔和margin\n                    const childWidth = children[i].getBoundingClientRect().width;\n                    totalWidth += childWidth;\n                    let searchWidth = this.suffixSize.width || 0;\n                    // 如果超出或等于maxTagCount，跳出循环\n                    if (this.isOverflow(i, totalWidth, searchWidth)) {\n                        this.state.displayMaxIndex = i;\n                        break;\n                    }\n                }\n            }\n\n            const displayValues = values.slice(0, this.state.displayMaxIndex);\n            this.state.displayOptions = options.filter((c) => displayValues.indexOf(c.value) !== -1);\n            // 计算剩余显示部分\n            const restIndex = Math.max(0, this.props.values.length - this.state.displayMaxIndex);\n            this.state.rest = restIndex > 0 ? restIndex : undefined;\n        }, () => [\n            this.tempRef.el, this.containerSize.width, this.suffixSize.width, this.props.values, this.props.options\n        ]);\n    }\n}\n\nexport default Overflow;\n","import { Component, useEffect, useRef, useState, xml } from '@odoo/owl';\nimport { baseProps, BaseProps } from '@/common/baseProps';\nimport { getPrefixCls, getSDSVG, stylesToString } from '@/components/_util/utils';\nimport _downSVG from '@/assets/down.svg';\nimport _searchSVG from '@/assets/search.svg';\nimport _emptySVG from '@/assets/empty.svg';\nimport _loadingSVG from '@/assets/loading-line.svg';\nimport _checkSVG from '@/assets/check.svg';\nimport classNames from 'classnames';\nimport List from '@/components/list/List';\nimport Trigger, { Placement } from '@/components/trigger/Trigger';\nimport './style/select.scss';\nimport { useEventListener } from '@/hooks/useEventListener';\nimport { useCompRef, useImperativeHandle } from '@/hooks/useImperativeHandle';\nimport useControllableState from '@/hooks/useControllableState';\nimport { useColsSearch } from '@/hooks/useColsSearch';\nimport { SizeType } from '@/components/_util/type';\nimport { useCancellableTimer } from '@/hooks/useCancellableTimer';\nimport { useResizeObserver } from '@/hooks/useSizeObserver';\nimport Overflow, { Option } from '@/components/select/Overflow';\nimport _closeSVG from '@/assets/close_fill.svg';\nimport { ItemHeight, Position } from '@/components/list/VirtualList';\n\nconst downSVG = getSDSVG(_downSVG, {\n    width: '1em',\n    height: '1em'\n});\n\nconst searchSVG = getSDSVG(_searchSVG, {\n    width: '1em',\n    height: '1em'\n});\n\nconst emptySVG = getSDSVG(_emptySVG, {\n    width: '64',\n    height: '41'\n});\n\nconst loadingSVG = getSDSVG(_loadingSVG, {\n    width: '1em',\n    height: '1em'\n});\n\nconst checkSVG = getSDSVG(_checkSVG, {\n    width: '1em',\n    height: '1em'\n});\n\nconst closeSVG = getSDSVG(_closeSVG, {\n    width: '1em',\n    height: '1em'\n});\n\ntype Value<T> = T | T[];\n\ntype Props = {\n    className?: string;\n    allowClear?: boolean;\n    autoClearSearchValue?: boolean;\n    getPopupContainer?: (triggerNode?: HTMLElement) => string; // 返回一个选择器字符串\n    placement?: Placement;\n    listHeight?: number;\n    disabled?: boolean;\n    multiple?: boolean;\n    value?: Value<string> | Value<number>;\n    defaultValue?: Value<string> | Value<number>;\n    size: SizeType,\n    placeholder?: string;\n    bordered?: boolean;\n    defaultOpen?: boolean;\n    autoFocus?: boolean;\n    popupClassName?: string;\n    popupMatchSelectWidth?: boolean;\n    destroyOnHide?: boolean;\n    showSearch?: boolean;\n    filterOption?: (searchValue: string, option: Option) => boolean;\n    filterSort?: (optionA: Option, optionB: Option) => number;\n    options: Option[];\n    loading?: boolean;\n    open?: boolean;\n    maxTagCount?: number | 'responsive';\n    virtual?: boolean;\n    itemHeight?: number | ItemHeight;\n    onSearch?: (value: string) => boolean;\n    onSelect?: (option: Option) => void;\n    onDeselect?: (option: Option) => void;\n    onClear?: () => void;\n    onDropdownVisibleChange?: (open: boolean) => void;\n    onFocus?: () => void;\n    onPopupScroll?: (event: MouseEvent, position?: Position) => void;\n} & BaseProps;\n\nconst selectClass = getPrefixCls('select');\nconst selectIconClass = getPrefixCls('select-icon');\nconst selectRotateIconClass = getPrefixCls('select-rotate-icon');\nconst selectSelectorClass = getPrefixCls('select-selector');\nconst selectDropdownClass = getPrefixCls('select-dropdown');\nconst dropdownEmptyClass = getPrefixCls('select-dropdown-empty');\nconst selectDropdownItemWrapperClass = getPrefixCls('select-dropdown-item-wrapper');\n// 需要额外包裹一层，因为item最外层有padding，点击事件到达不了，影响体验\nconst selectDropdownItemClass = getPrefixCls('select-dropdown-item');\nconst searchSpanClass = getPrefixCls('select-search-span');\nconst displaySpanClass = getPrefixCls('select-display-span');\n\ntype State = {\n    searchValue: string;\n    triggerNode?: HTMLElement;\n    focus: boolean;\n    multipleInputStyle?: string\n};\n\nclass Select extends Component<Props> {\n    static components = { List, Trigger, Overflow };\n\n    static props = {\n        className: { type: String, optional: true },\n        allowClear: { type: Boolean, optional: true },\n        autoClearSearchValue: { type: Boolean, optional: true },\n        getPopupContainer: { type: Function, optional: true },\n        placement: { type: String, optional: true },\n        listHeight: { type: Number, optional: true },\n        disabled: { type: Boolean, optional: true },\n        value: { type: [String, Array, Number], optional: true },\n        defaultValue: { type: [String, Array, Number], optional: true },\n        multiple: { type: Boolean, optional: true },\n        size: { type: String, optional: true },\n        placeholder: { type: String, optional: true },\n        bordered: { type: Boolean, optional: true },\n        defaultOpen: { type: Boolean, optional: true },\n        autoFocus: { type: Boolean, optional: true },\n        popupClassName: { type: String, optional: true },\n        popupMatchSelectWidth: { type: Boolean, optional: true },\n        destroyOnHide: { type: Boolean, optional: true },\n        showSearch: { type: Boolean, optional: true },\n        filterOption: { type: Function, optional: true },\n        filterSort: { type: Function, optional: true },\n        options: { type: Array },\n        loading: { type: Boolean, optional: true },\n        open: { type: Boolean, optional: true },\n        maxTagCount: { type: [Number, String], optional: true },\n        virtual: { type: Boolean, optional: true },\n        itemHeight: { type: [Number, Function], optional: true },\n        onSearch: { type: Function, optional: true },\n        onSelect: { type: Function, optional: true },\n        onDeselect: { type: Function, optional: true },\n        onClear: { type: Function, optional: true },\n        onDropdownVisibleChange: { type: Function, optional: true },\n        onFocus: { type: Function, optional: true },\n        onPopupScroll: { type: Function, optional: true },\n        ...baseProps\n    };\n\n    static defaultProps = {\n        autoClearSearchValue: true,\n        listHeight: 256,\n        virtual: false,\n        popupMatchSelectWidth: true,\n        destroyOnHide: true,\n        multiple: false,\n        bordered: true,\n        placement: 'bottomLeft'\n    };\n\n    state = useState<State>({\n        searchValue: '',\n        focus: this.props.autoFocus || false,\n        triggerNode: undefined,\n        multipleInputStyle: undefined\n    });\n\n    controllableState = useControllableState<{ value?: Value<string> | Value<number>, open?: boolean }>(this.props, {\n        value: this.props.defaultValue ?? this.props.multiple ? [] : undefined,\n        open: false\n    });\n\n    colsState = useColsSearch(this.props.options, this.props.filterOption, this.props.filterSort);\n\n    cancelableTimer = useCancellableTimer();\n\n    containerRef = useRef('container');\n\n    searchTempRef = useRef('searchTemp');\n\n    searchSpanRef = useRef('searchSpan');\n\n    searchRef = useRef('search');\n\n    triggerRef = useCompRef();\n\n    static template = xml`\n<span t-ref=\"container\" t-att-class=\"getClass()\" t-on-click=\"onClickContainer\">\n    <span class=\"${selectSelectorClass}\">\n        <span t-if=\"showPlaceholder()\" class=\"${selectSelectorClass}-placeholder\"><t t-esc=\"props.placeholder\"/></span>\n        <div class=\"${selectSelectorClass}-temp\" t-ref=\"searchTemp\"><t t-esc=\"state.searchValue\"/></div>\n        <t t-set=\"searchClass\" t-value=\"getSearchClass()\"/>\n        <t t-if=\"props.multiple\">\n            <Overflow slots=\"props.slots\" className=\"'${selectSelectorClass}-tags'\" values=\"controllableState.state.value\" maxTagCount=\"props.maxTagCount\" options=\"props.options\" handleDelete.bind=\"handleDeleteChoice\">\n                <t t-set-slot=\"suffix\">\n                    <t t-if=\"props.showSearch\">\n                        <span t-att-class=\"searchClass.search\">\n                            <span t-ref=\"searchSpan\">\n                                <input t-ref=\"search\" t-on-input=\"onInput\" t-att-value=\"state.searchValue\" type=\"text\"/>\n                            </span>\n                        </span>\n                    </t>\n                </t>\n            </Overflow>\n        </t>\n        <t t-else=\"\">\n            <t t-if=\"props.showSearch\">\n                <span t-att-class=\"searchClass.search\"><input t-on-input=\"onInput\" t-att-value=\"state.searchValue\" type=\"text\"/></span>\n            </t>\n            <t t-set=\"displayOption\" t-value=\"getOption(controllableState.state.value)\"/>\n            <span t-if=\"displayOption\" t-att-class=\"searchClass.display\">\n                <t t-slot=\"label\" data=\"displayOption\">\n                    <t t-esc=\"displayOption.label\"/>\n                </t>\n            </span>\n        </t>\n    </span>\n    <Trigger ref=\"triggerRef\" onScroll.bind=\"onScroll\" className=\"getPopupClass()\" isOpen=\"controllableState.state.open\" triggerNode=\"state.triggerNode\" \n        getPopupContainer=\"props.getPopupContainer\" destroyOnHide=\"props.destroyOnHide\" getStyle.bind=\"getDropdownStyle\" placement=\"props.placement\">\n        <t t-if=\"colsState.state.displayCols.length === 0\">\n            <t t-slot=\"empty\">\n                <div class=\"${dropdownEmptyClass}\">\n                    <div>${emptySVG}</div>\n                    <div>暂无数据</div>\n                </div>\n            </t>\n        </t>\n        <t t-else=\"\">\n            <List dataSource=\"colsState.state.displayCols\" itemClassName.bind=\"getItemClass\" virtual=\"props.virtual\" itemHeight=\"props.itemHeight\" height=\"props.listHeight\" onScroll.bind=\"onScroll\">\n                <t t-set-slot=\"item\" t-slot-scope=\"scope\">\n                    <div class=\"${selectDropdownItemClass}\" t-on-click.synthetic=\"() => this.handleChoice(scope.data)\">\n                        <span>\n                            <t t-slot=\"label\" data=\"scope.data\">\n                                <t t-esc=\"scope.data.label\"/>\n                            </t>\n                        </span>\n                        <span class=\"${selectDropdownItemClass}-icon\" t-if=\"this.showSelectedSuffix(scope.data)\">${checkSVG}</span>\n                    </div>\n                </t>\n            </List>        \n        </t>\n    </Trigger>\n    <span class=\"${selectIconClass}\">\n        <t t-if=\"props.loading\"><span class=\"${selectRotateIconClass}\">${loadingSVG}</span></t>\n        <t t-elif=\"state.searchValue\">${searchSVG}</t>\n        <t t-else=\"\">${downSVG}</t>\n        \n        <span t-if=\"!props.disabled &amp;&amp; props.allowClear\" class=\"${selectIconClass}-clear\" t-on-click=\"handleClear\">\n            ${closeSVG}\n        </span>\n    </span>\n </span>   \n    `;\n\n    /**\n     * 判断是否显示placeholder的逻辑\n     * @protected\n     */\n    protected showPlaceholder() {\n        const { multiple } = this.props;\n        if (!!this.state.searchValue) {\n            return false;\n        }\n\n        if (!multiple) {\n            return !this.controllableState.state.value;\n        }\n        return (this.controllableState.state.value as (string | number)[]).length === 0;\n    }\n\n    /**\n     * 搜索值变化时触发回调\n     * @param event\n     * @protected\n     */\n    protected onInput(event: Event) {\n        const value = (event.currentTarget as HTMLInputElement).value;\n        this.state.searchValue = value;\n        this.colsState.state.searchValue = value;\n        this.props.onSearch?.(value);\n    }\n\n    /**\n     * 清空搜索值\n     * @protected\n     */\n    protected clear() {\n        this.state.searchValue = '';\n        this.colsState.state.searchValue = '';\n    }\n\n    /**\n     * 延时清空搜索值，但是会马上清空显示的值\n     * @protected\n     */\n    protected timerClear() {\n        // 先清空searchValue使展示正常\n        this.state.searchValue = '';\n        this.cancelableTimer.run(this.clear.bind(this), 1000);\n    }\n\n    /**\n     * 点击最外层容器时触发的回调\n     * @param event\n     * @protected\n     */\n    protected onClickContainer(event: MouseEvent) {\n        if (!this.props.disabled) {\n            // 打开时如果有searchRef，则进行聚焦，仅multiple有用\n            this.searchRef.el?.focus();\n            // 如果已经open并且允许search，则不进行关闭\n            if (this.controllableState.state.open && this.props.showSearch) {\n                return;\n            }\n            this.toggleOpen();\n            this.state.focus = true;\n            this.props.onFocus?.();\n        }\n    }\n\n    /**\n     * 下拉框的显示状态改变时触发\n     * @param open 是否显示\n     * @protected\n     */\n    protected onDropdownVisibleChange(open: boolean) {\n        this.controllableState.setState({\n            open\n        });\n        this.props.onDropdownVisibleChange?.(open);\n    }\n\n    /**\n     * 切换下拉框的显示状态\n     * @param force 切换状态\n     * @protected\n     */\n    protected toggleOpen(force?: boolean) {\n        if (!this.props.disabled) {\n            this.onDropdownVisibleChange(force ?? !this.controllableState.state.open);\n            if (this.controllableState.state.open) {\n                this.clear();\n                this.cancelableTimer.cancel();\n                this.state.triggerNode = this.containerRef.el!;\n            }\n        }\n    }\n\n    /**\n     * select组件的样式类\n     * @protected\n     */\n    protected getClass() {\n        const { size, className, disabled, bordered } = this.props;\n\n        return classNames(className, selectClass, {\n            [`${selectClass}-borderless`]: !bordered,\n            [`${selectClass}-focus`]: this.state.focus,\n            [`${selectClass}-multiple`]: !!this.props.multiple,\n            [`${selectClass}-isOpen`]: this.controllableState.state.open,\n            [`${selectClass}-searchable`]: this.props.showSearch,\n            [`${selectClass}-disabled`]: !!disabled,\n            [`${selectClass}-sm`]: size === 'small',\n            [`${selectClass}-lg`]: size === 'large',\n            [`${selectClass}-vir`]: false\n        });\n    }\n\n    /**\n     * 搜索相关部分的样式\n     * @protected\n     */\n    protected getSearchClass() {\n        return {\n            search: classNames(searchSpanClass, {\n                [`${searchSpanClass}-multiple`]: !!this.props.multiple\n            }),\n            display: classNames(displaySpanClass, {\n                [`${selectClass}-v-hidden`]: !this.props.multiple && !!this.state.searchValue  // 多选模式下不隐藏\n            })\n        };\n    }\n\n    /**\n     * 下拉框的class\n     * @protected\n     */\n    protected getPopupClass() {\n        return classNames(selectDropdownClass, this.props.popupClassName, {\n            [`${selectDropdownClass}-virtual`]: !!this.props.virtual\n        });\n    }\n\n    /**\n     * 选项的样式类\n     * @param item\n     * @param index\n     * @protected\n     */\n    protected getItemClass(item: Option, index: number) {\n        if (!this.props.multiple) {\n            return classNames(selectDropdownItemWrapperClass, {\n                [`${selectDropdownItemClass}-selected`]: item.value === this.controllableState.state.value\n            });\n        }\n\n        return classNames(selectDropdownItemWrapperClass, {\n            [`${selectDropdownItemClass}-selected`]: (this.controllableState.state.value as (string | number)[]).indexOf(\n                item.value) !== -1\n        });\n    }\n\n    /**\n     * 下拉框的样式style\n     * @param triggerNode\n     * @protected\n     */\n    protected getDropdownStyle(triggerNode?: HTMLElement) {\n        if (!triggerNode) {\n            return;\n        }\n\n        const { clientWidth } = triggerNode;\n        const style = {\n            'max-height': `${this.props.listHeight}px`\n        };\n        if (this.props.popupMatchSelectWidth) {\n            style['width'] = `${clientWidth}px`;\n        }\n\n        return stylesToString(style);\n    }\n\n    /**\n     * 判断下拉框中是否显示已选的后缀标识\n     * @param option 选项\n     * @protected\n     */\n    protected showSelectedSuffix(option: Option) {\n        return this.props.multiple && (this.controllableState.state.value as (string | number)[]).indexOf(\n            option.value) !== -1;\n    }\n\n    /**\n     * 点击外部区域时，关闭下拉框\n     * @param event\n     * @protected\n     */\n    protected onClickOutsideHandler(event: MouseEvent) {\n        const target = event.target as HTMLElement;\n        // 在点击非选择框区域和非选项区域时，关闭下拉框\n        if (!this.containerRef.el?.contains(target) && !this.triggerRef.current?.wrapperRef.el?.contains(target)) {\n            if (this.controllableState.state.open) {\n                this.toggleOpen(false);\n            }\n            this.state.focus = false;\n            this.timerClear();\n        }\n    }\n\n    protected onScroll(event: MouseEvent, position?: Position) {\n        this.props.onPopupScroll?.(event, position);\n    }\n\n    /**\n     * 清空选项的回调\n     * @param event\n     * @protected\n     */\n    protected handleClear(event: MouseEvent) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.controllableState.setState({\n            value: this.props.multiple ? [] : undefined\n        });\n        this.props.onClear?.();\n    }\n\n    /**\n     * 选中下拉选项的回调\n     * @param option\n     * @protected\n     */\n    protected handleChoice(option: Option) {\n        if (this.props.multiple) {\n            const { value } = option;\n            const stateValue = [...this.controllableState.state.value as any[]];\n            const index = stateValue.indexOf(value);\n            if (index === -1) {\n                // 新选中\n                stateValue.push(value);\n                this.controllableState.setState({\n                    value: stateValue\n                });\n                this.props.onSelect?.(option);\n            } else {\n                // 取消选中\n                this.handleDeleteChoice(option)\n            }\n\n        }else {\n            this.controllableState.setState({\n                value: option.value\n            });\n            this.props.onSelect?.(option);\n        }\n\n        if (!this.props.multiple) {\n            this.timerClear();\n            this.onDropdownVisibleChange(false);\n        } else if (this.props.autoClearSearchValue) {\n            this.clear();\n        }\n    }\n\n    /**\n     * 取消选中值的回调\n     * @param option\n     * @protected\n     */\n    protected handleDeleteChoice(option: Option) {\n        const filterValues = (this.controllableState.state.value as any[]).filter((v) => v !== option.value);\n        this.controllableState.setState({\n            value: filterValues\n        });\n        this.props.onDeselect?.(option);\n    }\n\n    /**\n     * 根据value值获取对应的option\n     * @param value\n     * @protected\n     */\n    protected getOption(value: string | number) {\n        return this.props.options.find((c) => c.value === value);\n    }\n\n    public setup(): void {\n        const target = { el: window };\n        useImperativeHandle(() => ({\n            focus: () => {\n                this.state.focus = true;\n                this.props.onFocus?.();\n            },\n            blur: () => {\n                this.state.focus = false;\n            }\n        }), () => [])\n\n        useEventListener(target, 'mousedown', this.onClickOutsideHandler);\n\n        // 监听尺寸变化，如果是打开状态并且尺寸发生了变化，则进行对齐，使用ResizeObserver节约性能开销\n        useResizeObserver(this.containerRef, (entry) => {\n            if (this.controllableState.state.open) {\n                this.triggerRef.current?.align();\n            }\n        });\n\n        useEffect(() => {\n            this.colsState.state.columns = this.props.options;\n        }, () => [this.props.options]);\n\n        // 是否默认展开逻辑\n        useEffect(() => {\n            if (this.props.defaultOpen && !this.props.disabled) {\n                this.state.triggerNode = this.containerRef.el!;\n                this.onDropdownVisibleChange(true);\n            }\n            // 初始有焦点时触发一次onFocus事件\n            if (this.props.autoFocus) {\n                this.props.onFocus?.();\n            }\n        }, () => []);\n\n        // 在输入框宽度不足时进行适配换行处理\n        useEffect(() => {\n            if (!this.searchSpanRef.el) {\n                return;\n            }\n\n            let width = '4px';\n            if (this.state.searchValue) {\n                width = getComputedStyle(this.searchTempRef.el!).width;\n            }\n            this.searchSpanRef.el.style.width = width;\n        }, () => [this.state.searchValue, this.searchSpanRef.el]);\n    }\n}\n\nexport default Select;\n","import { Component, xml } from '@odoo/owl';\nimport { baseProps, BaseProps } from '@/common/baseProps';\nimport { getPrefixCls } from '@/components/_util/utils';\nimport './style/checkbox.scss';\nimport classNames from 'classnames';\nimport useControllableState from '@/hooks/useControllableState';\nimport Group from './Group';\n\ntype Props = {\n    className?: string;\n    disabled?: boolean;\n    defaultValue?: boolean;\n    value?: boolean;\n    indeterminate?: boolean;\n    onChange?: (checked: boolean) => void;\n    name?: string;\n} & BaseProps;\n\nconst checkboxClass = getPrefixCls('checkbox');\nconst checkboxWrapperClass = `${checkboxClass}-wrapper`;\nconst checkboxInputClass = `${checkboxClass}-input`;\nconst checkboxInnerClass = `${checkboxClass}-inner`;\n\nexport default class Checkbox extends Component<Props> {\n    static props = {\n        className: { type: String, optional: true },\n        disabled: { type: Boolean, optional: true },\n        defaultValue: { type: Boolean, optional: true },\n        value: { type: Boolean, optional: true },\n        indeterminate: { type: Boolean, optional: true },\n        onChange: { type: Function, optional: true },\n        name: { type: String, optional: true },\n        ...baseProps\n    };\n\n    get checkboxGroup(): Group | undefined {\n        return this.env.checkboxGroup;\n    }\n\n    get checkboxGroupValue(): string[] | undefined {\n        return this.checkboxGroup?.controllableState.state.value;\n    }\n\n    get mergedValue() {\n        // 如果有checkboxGroup，则从checkboxGroup中获取value\n        if (this.checkboxGroupValue && this.props.name) {\n            return this.checkboxGroupValue.indexOf(this.props.name) > -1;\n        }\n        return this.controllableState.state.value;\n    }\n\n    get disabled() {\n        return this.env.checkboxGroup?.props.disabled ?? this.props.disabled;\n    }\n\n    controllableState = useControllableState(this.props, {\n        value: this.props.defaultValue ?? false\n    });\n\n    static template = xml`\n<t t-set=\"classes\" t-value=\"getClasses()\"></t>\n<label t-att-class=\"classes.wrapper\">\n    <span class=\"${checkboxClass}\" t-on-click=\"onClick\">\n        <t t-if=\"mergedValue\">\n            <input type=\"checkbox\" t-att-class=\"classes.input\" checked=\"checked\" t-att-disabled=\"props.disabled\"/>\n        </t>\n        <t t-else=\"\">\n            <input type=\"checkbox\" t-att-class=\"classes.input\" t-att-disabled=\"props.disabled\"/>\n        </t>\n        <span t-att-class=\"classes.inner\"/>\n    </span>\n    \n    <span>\n        <t t-slot=\"default\"/>\n    </span>\n</label>    \n`;\n\n    protected getClasses() {\n        return {\n            wrapper: classNames(this.props.className, checkboxWrapperClass, {\n                [`${checkboxWrapperClass}-disabled`]: this.disabled,\n                [`${checkboxWrapperClass}-checked`]: this.mergedValue,\n                [`${checkboxWrapperClass}-indeterminate`]: this.props.indeterminate\n            }),\n            input: checkboxInputClass,\n            inner: classNames(checkboxInnerClass, {\n                [`${checkboxInnerClass}-checked`]: this.mergedValue,\n                [`${checkboxInnerClass}-indeterminate`]: this.props.indeterminate\n            })\n        };\n    }\n\n    protected onClick() {\n        const { indeterminate } = this.props;\n        if (this.disabled || indeterminate) {\n            return;\n        }\n        this.toggleChecked();\n    }\n\n    /**\n     * 在checkboxGroup中切换选中状态\n     * @param force\n     * @protected\n     */\n    protected toggleCheckedInGroup(force?: boolean) {\n        const currentChecked = this.checkboxGroupValue!.indexOf(this.props.name!) !== -1;\n        const toCheck = force ?? !currentChecked;\n        this.env.checkboxGroup?.onChange(toCheck, this.props.name);\n        this.props.onChange?.(toCheck);\n    }\n\n    /**\n     * 在独立使用时切换选中状态\n     * @param force\n     * @protected\n     */\n    protected toggleCheckedWithoutGroup(force?: boolean) {\n        const toCheck = force ?? !this.controllableState.state.value;\n        this.controllableState.setState({\n            value: toCheck\n        });\n        this.props.onChange?.(toCheck);\n    }\n\n    /**\n     * 切换选中状态\n     * @param force\n     * @protected\n     */\n    protected toggleChecked(force?: boolean) {\n        if (this.checkboxGroup && this.props.name) {\n            this.toggleCheckedInGroup(force);\n        } else {\n            this.toggleCheckedWithoutGroup(force);\n        }\n    }\n}\n","import { Component, useChildSubEnv, xml } from '@odoo/owl';\nimport { baseProps, BaseProps } from '@/common/baseProps';\nimport Checkbox from './Checkbox';\nimport { isObject } from '@/components/_util';\nimport useControllableState from '@/hooks/useControllableState';\n\ntype Option = {\n    label: string,\n    name: string\n    disabled?: boolean\n}\n\ntype Props = {\n    disabled?: boolean;\n    options?: (string | Option)[];\n    onChange?: (checkedValues: (string)[]) => void;\n    defaultValue?: string[];\n    value?: string[];\n} & BaseProps;\n\nexport default class Group extends Component<Props> {\n    static props = {\n        disabled: { type: Boolean, optional: true },\n        options: { type: Array, optional: true },\n        onChange: { type: Function, optional: true },\n        defaultValue: { type: Array, optional: true },\n        value: { type: Array, optional: true },\n        ...baseProps\n    };\n\n    static components = { Checkbox };\n\n    static template = xml`\n<t t-if=\"props.options\">\n    <t t-foreach=\"props.options\" t-as=\"option\" t-key=\"option_index\">\n        <t t-set=\"checkboxName\" t-value=\"option.name || option\"/>\n        <Checkbox name=\"checkboxName\" value=\"controllableState.state.value.indexOf(checkboxName) > -1\" disabled=\"option.disabled\">\n            <t t-esc=\"showOption(option)\"/>\n        </Checkbox>\n    </t>  \n</t>  \n<t t-else=\"\">\n    <t t-slot=\"default\"/>\n</t>\n`;\n    controllableState = useControllableState(this.props, {\n        value: this.props.defaultValue ?? []\n    });\n\n    protected showOption(option: string | number | Option) {\n        if (isObject(option)) {\n            return option.label;\n        } else if (!!option) {\n            return option;\n        }\n    }\n\n    protected onChange(checkedValue: boolean, name: string) {\n        const value = [...this.controllableState.state.value];\n        if (checkedValue) {\n            value.push(name);\n        } else {\n            const index = value.indexOf(name);\n            value.splice(index, 1);\n        }\n        this.controllableState.setState({ value });\n        this.props.onChange?.(value);\n    }\n\n    public setup(): void {\n        useChildSubEnv({ checkboxGroup: this });\n    }\n}\n","import { Component, xml } from '@odoo/owl';\nimport { baseProps, BaseProps } from '@/common/baseProps';\nimport { getPrefixCls, getSDSVG } from '@/components/_util/utils';\nimport _loadingSVG from '@/assets/loading-line.svg';\nimport classNames from 'classnames';\nimport './style/switch.scss';\nimport useControllableState from '@/hooks/useControllableState';\n\ntype Props = {\n    className?: string;\n    value?: boolean;\n    defaultValue?: boolean;\n    disabled?: boolean;\n    loading?: boolean;\n    size?: 'small' | 'default'\n    onChange?: (value: boolean) => void;\n} & BaseProps;\n\nconst switchClass = getPrefixCls('switch');\nconst switchInnerClass = `${switchClass}-inner`;\nconst switchLoadingClass = `${switchClass}-loading`;\n\nconst loadingSVG = getSDSVG(_loadingSVG, {\n    width: '100%',\n    height: '100%'\n}, switchLoadingClass);\n\nexport default class Switch extends Component<Props> {\n    static props = {\n        className: { type: String, optional: true },\n        value: { type: Boolean, optional: true },\n        defaultValue: { type: Boolean, optional: true },\n        disabled: { type: Boolean, optional: true },\n        loading: { type: Boolean, optional: true },\n        size: { type: String, optional: true },\n        onChange: { type: Function, optional: true },\n        ...baseProps\n    };\n\n    static template = xml`\n<t t-set=\"classes\" t-value=\"getClasses()\"></t>\n<span t-att-class=\"classes.switch\" t-on-click=\"onClick\">\n    <span t-att-class=\"classes.handle\">\n        <t t-if=\"props.loading\">${loadingSVG}</t>\n    </span>\n    <span t-att-class=\"classes.inner\">\n        <span class=\"${switchInnerClass}-checked\">\n            <t t-slot=\"checked\"/>\n        </span>\n        <span class=\"${switchInnerClass}-unchecked\">\n            <t t-slot=\"unchecked\"/>\n        </span>\n    </span>\n</span>    \n`;\n\n    controllableState = useControllableState<{ value: boolean }>(this.props, {\n        value: this.props.defaultValue ?? false\n    });\n\n    get disabled() {\n        return this.props.disabled || this.props.loading;\n    }\n\n    protected getClasses() {\n        return {\n            'switch': classNames(switchClass, this.props.className, {\n                [`${switchClass}-checked`]: this.controllableState.state.value,\n                [`${switchClass}-disabled`]: this.disabled,\n                [`${switchClass}-sm`]: this.props.size === 'small'\n            }),\n            handle: `${switchClass}-handle`,\n            inner: switchInnerClass\n        };\n    }\n\n    protected onClick() {\n        if (this.disabled) {\n            return;\n        }\n        this.handleToggle();\n    }\n\n    protected handleToggle(force?: boolean) {\n        const toValue = force ?? !this.controllableState.state.value;\n        this.controllableState.setState({\n            value: toValue\n        });\n        this.props.onChange?.(toValue);\n    }\n}\n"],"names":[],"sourceRoot":""}