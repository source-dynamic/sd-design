{"version":3,"file":"200.71a68183.iframe.bundle.js","mappings":";;;;AAuEA;;;;ACjCA;;;;AC0EA;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;AAGA;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;ACzCA;;;;;AC3EA;;AAEA;;;AAGA;;;;;;;;;;;;;;;;;;;AAqBA;;;;;;;;;;;;;;;;;;;;;;;ACdA;;AC8EA;;AAEA;;;;AAIA;;AAEA;;;;;;;AAOA;;AAIA;;;;AC5IA;;AC8CA;;;;;;AAQA;;;ACPA;;;;;AAKA;;;;;;;;;;;;;;;;;;AAkBA;;;;;AAOA;;;ACxBA;;;;AAIA;;;;AAMA;;;;;ACFA;;;AAGA;;;;;;;;;AASA;;;;;AAKA;;;;;;AAQA;;ACwFA;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AACA;;;;;;;;AAQA;;;;;;AAMA;;;;;;AAMA;AACA;AACA;AACA;;AAEA;AACA;;;;AAUA","sources":["webpack://sd-design/./src/components/grid/Col.ts","webpack://sd-design/./src/components/grid/Row.ts","webpack://sd-design/./src/components/input/ClearableLabeledWrapper.ts","webpack://sd-design/./src/components/input/Input.ts","webpack://sd-design/./src/components/input/Password.ts","webpack://sd-design/./src/components/input/TextArea.ts","webpack://sd-design/./src/components/input-number/InputNumber.ts","webpack://sd-design/./src/components/list/Item.ts","webpack://sd-design/./src/components/list/VirtualList.ts","webpack://sd-design/./src/components/list/List.ts","webpack://sd-design/./src/components/trigger/trigger.ts","webpack://sd-design/./src/components/select/Overflow.ts","webpack://sd-design/./src/components/select/Select.ts"],"sourcesContent":["import { Component, xml } from '@odoo/owl';\r\nimport { responsiveArray } from '@/components/_util/responsiveObserve';\r\nimport { getPrefixCls, stylesToString } from '@/components/_util/utils';\r\nimport classNames from 'classnames';\r\nimport Row from './Row';\r\nimport { baseProps, BaseProps } from '@/common/baseProps';\r\n\r\ntype ColSpanType = number | string;\r\n\r\ntype IColSize = {\r\n    span?: ColSpanType;\r\n    order?: ColSpanType;\r\n    offset?: ColSpanType;\r\n    push?: ColSpanType;\r\n    pull?: ColSpanType;\r\n};\r\n\r\ntype Props = {\r\n    className?: string;\r\n    span?: ColSpanType;\r\n    order?: ColSpanType;\r\n    offset?: ColSpanType;\r\n    push?: ColSpanType;\r\n    pull?: ColSpanType;\r\n    xs?: ColSpanType | IColSize;\r\n    sm?: ColSpanType | IColSize;\r\n    md?: ColSpanType | IColSize;\r\n    lg?: ColSpanType | IColSize;\r\n    xl?: ColSpanType | IColSize;\r\n    xxl?: ColSpanType | IColSize;\r\n    flex?: number | 'none' | 'auto' | string;\r\n} & BaseProps;\r\n\r\ntype Env = {\r\n    row: Row\r\n}\r\n\r\nconst parseFlex = (flex: number | 'none' | 'auto' | string): string => {\r\n    if (typeof flex === 'number') {\r\n        return `${flex} ${flex} auto`;\r\n    }\r\n    if (/^\\d+(\\.\\d+)?(px|em|rem|%)$/.test(flex)) {\r\n        return `0 0 ${flex}`;\r\n    }\r\n    return flex;\r\n};\r\n\r\nexport default class Col extends Component<Props, Env> {\r\n    static props = {\r\n        className: { type: String, optional: true },\r\n        span: { type: [Number, String], optional: true },\r\n        order: { type: [Number, String], optional: true },\r\n        offset: { type: [Number, String], optional: true },\r\n        push: { type: [Number, String], optional: true },\r\n        pull: { type: [Number, String], optional: true },\r\n        xs: { type: [Number, Object], optional: true },\r\n        sm: { type: [Number, Object], optional: true },\r\n        md: { type: [Number, Object], optional: true },\r\n        lg: { type: [Number, Object], optional: true },\r\n        xl: { type: [Number, Object], optional: true },\r\n        xxl: { type: [Number, Object], optional: true },\r\n        flex: { type: [Number, String], optional: true },\r\n        ...baseProps\r\n    };\r\n\r\n    static template = xml`\r\n    <div t-att-class=\"getClasses()\" t-att-style=\"getStyle()\">\r\n        <t t-slot=\"default\"/>\r\n    </div>\r\n    `;\r\n\r\n    protected getStyle(): string | undefined {\r\n        let colStyle: { [key: string]: any } = {};\r\n        if (this.props.flex) {\r\n            colStyle.flex = parseFlex(this.props.flex);\r\n        }\r\n        return stylesToString(colStyle) || undefined;\r\n    }\r\n\r\n    protected getClasses(): string {\r\n        const { span, order, offset, push, pull } = this.props;\r\n        const prefixCls = getPrefixCls('col');\r\n        let sizeClassObj = {};\r\n        // 组装响应式class类\r\n        responsiveArray.forEach((size) => {\r\n            let sizeProps: IColSize = {};\r\n            const propSize = this.props[size];\r\n            if (typeof propSize === 'number') {\r\n                sizeProps.span = propSize;\r\n            } else if (typeof propSize === 'object') {\r\n                sizeProps = propSize || {};\r\n            }\r\n            sizeClassObj = {\r\n                ...sizeClassObj,\r\n                [`${prefixCls}-${size}-${sizeProps.span}`]: sizeProps.span !== undefined,\r\n                [`${prefixCls}-${size}-order-${sizeProps.order}`]:\r\n                sizeProps.order || sizeProps.order === 0,\r\n                [`${prefixCls}-${size}-offset-${sizeProps.offset}`]:\r\n                sizeProps.offset || sizeProps.offset === 0,\r\n                [`${prefixCls}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,\r\n                [`${prefixCls}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0\r\n            };\r\n        });\r\n\r\n        return classNames(\r\n            prefixCls,\r\n            this.props.className,\r\n            {\r\n                [`${prefixCls}-${span}`]: span !== undefined,\r\n                [`${prefixCls}-order-${order}`]: order,\r\n                [`${prefixCls}-offset-${offset}`]: offset,\r\n                [`${prefixCls}-push-${push}`]: push,\r\n                [`${prefixCls}-pull-${pull}`]: pull\r\n            },\r\n            sizeClassObj\r\n        );\r\n    }\r\n}\r\n","import { Component, useChildSubEnv, useEffect, useState, xml } from '@odoo/owl';\r\nimport { Breakpoint, responsiveArray, responsiveObserve, ScreenMap } from '@/components/_util/responsiveObserve';\r\nimport classNames from 'classnames';\r\nimport { getPrefixCls, stylesToString } from '@/components/_util/utils';\r\nimport { baseProps, BaseProps } from '@/common/baseProps';\r\n\r\ntype State = {\r\n    className?: string;\r\n    style?: string;\r\n    screens: ScreenMap;\r\n};\r\n\r\ntype Gutter = number | Partial<Record<Breakpoint, number>>;\r\n\r\ntype Props = {\r\n    className?: string;\r\n    gutter?: Gutter | [Gutter, Gutter];\r\n    align?: 'top' | 'middle' | 'bottom';\r\n    justify?: 'start' | 'end' | 'center' | 'space-around' | 'space-between';\r\n    wrap?: boolean;\r\n} & BaseProps;\r\n\r\nexport default class Row extends Component<Props> {\r\n    static props = {\r\n        className: { type: String, optional: true },\r\n        gutter: { type: [Number, Array], optional: true },\r\n        align: { type: String, optional: true },\r\n        justify: { type: String, optional: true },\r\n        wrap: { type: Boolean, optional: true },\r\n        ...baseProps\r\n    };\r\n\r\n    static template: string = xml`\r\n        <div t-att-class=\"state.className\" t-att-style=\"state.style\">\r\n            <t t-slot=\"default\"/>\r\n        </div>\r\n    `;\r\n\r\n    state = useState<State>({\r\n        className: undefined,\r\n        style: undefined,\r\n        screens: {\r\n            xs: true,\r\n            sm: true,\r\n            md: true,\r\n            lg: true,\r\n            xl: true,\r\n            xxl: true\r\n        }\r\n    });\r\n\r\n    protected getGutter(screens: ScreenMap): [number, number] {\r\n        const results: [number, number] = [0, 0];\r\n        const { gutter = 0 } = this.props;\r\n        const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, 0];\r\n        normalizedGutter.forEach((g, index) => {\r\n            if (typeof g === 'object') {\r\n                for (let breakpoint of responsiveArray) {\r\n                    if (screens[breakpoint] && g[breakpoint] !== undefined) {\r\n                        results[index] = g[breakpoint] as number;\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                results[index] = g || 0;\r\n            }\r\n        });\r\n        return results;\r\n    }\r\n\r\n    protected getStyle(screens: ScreenMap): Record<string, string> {\r\n        const gutter = this.getGutter(screens);\r\n\r\n        return {\r\n            ...(gutter[0] > 0\r\n                ? {\r\n                    'column-gap ': `${gutter[0]}px`\r\n                }\r\n                : {}),\r\n            ...(gutter[1] > 0\r\n                ? {\r\n                    'row-gap': `${gutter[1]}px`\r\n                }\r\n                : {})\r\n        };\r\n    }\r\n\r\n    protected getClasses(): string {\r\n        const { justify, align, wrap } = this.props;\r\n        const prefixCls = getPrefixCls('row');\r\n        return classNames(this.props.className, prefixCls, {\r\n            [`${prefixCls}-${justify}`]: justify,\r\n            [`${prefixCls}-${align}`]: align,\r\n            [`${prefixCls}-nowrap`]: wrap === false\r\n        });\r\n    }\r\n\r\n    setup(): void {\r\n        useChildSubEnv({ row: this });\r\n        useEffect(() => {\r\n            const token = responsiveObserve.subscribe((screens: ScreenMap) => {\r\n                const currentGutter = this.props.gutter || 0;\r\n                if (\r\n                    (!Array.isArray(currentGutter) && typeof currentGutter === 'object') ||\r\n                    (Array.isArray(currentGutter) &&\r\n                        (typeof currentGutter[0] === 'object' || typeof currentGutter[1] === 'object'))\r\n                ) {\r\n                    this.state.screens = screens;\r\n                }\r\n                this.state.style = stylesToString(this.getStyle(screens)) || undefined;\r\n                this.state.className = this.getClasses() || undefined;\r\n            });\r\n\r\n            return () => {\r\n                responsiveObserve.unsubscribe(token);\r\n            };\r\n        }, () => [this.props]);\r\n    }\r\n}\r\n","import { Component, useState, xml } from '@odoo/owl';\r\nimport { SizeType } from '@/components/_util/type';\r\nimport { getPrefixCls, getSDSVG } from '@/components/_util/utils';\r\nimport classNames from 'classnames';\r\nimport { getInputClassName } from '@/components/input/utils';\r\nimport _closeFillSVG from '@/assets/close_fill.svg';\r\nimport './style/clearable-labeled-wrapper.scss';\r\nimport { baseProps, BaseProps } from '@/common/baseProps';\r\n\r\nconst closeFillSVG = getSDSVG(_closeFillSVG, {\r\n    width: '1em',\r\n    height: '1em'\r\n});\r\n\r\n/** This basic props required for input and textarea. */\r\ntype IBasicProps = {\r\n    className?: string;\r\n    inputType: 'text' | 'input';\r\n    direction?: 'ltr' | 'rtl';\r\n    value?: any;\r\n    allowClear?: boolean;\r\n    disabled?: boolean;\r\n    focused?: boolean;\r\n    readOnly?: boolean;\r\n    bordered: boolean;\r\n    handleReset: (event: MouseEvent) => void;\r\n    count?: string;\r\n} & BaseProps;\r\n\r\n/** This props only for input. */\r\ntype IClearableWrapperProps = {\r\n    size?: SizeType;\r\n} & IBasicProps;\r\n\r\ntype State = {}\r\n\r\nconst showCountSpanClass = getPrefixCls('input-show-count-suffix');\r\n\r\nexport default class ClearableLabeledWrapper extends Component<IClearableWrapperProps> {\r\n\r\n    static props = {\r\n        className: { type: String, optional: true },\r\n        inputType: { type: String, optional: true },\r\n        direction: { type: String, optional: true },\r\n        value: { type: [String, Number], optional: true },\r\n        allowClear: { type: Boolean, optional: true },\r\n        disabled: { type: Boolean, optional: true },\r\n        focused: { type: Boolean, optional: true },\r\n        readOnly: { type: Boolean, optional: true },\r\n        bordered: { type: Boolean, optional: true },\r\n        handleReset: { type: Function, optional: true },\r\n        count: { type: String, optional: true },\r\n        size: { type: String, optional: true },\r\n        ...baseProps\r\n    }\r\n\r\n    /**\r\n     * 渲染清除按钮的模版\r\n     */\r\n    static clearTemplate: string = `\r\n        <t t-set=\"clearIconClass\" t-value=\"renderClearIconClass()\"/>\r\n        <span\r\n          role=\"button\"\r\n          aria-label=\"close-circle\"\r\n          tabIndex=\"-1\"\r\n          t-on-click.stop=\"props.handleReset\"\r\n          t-att-class=\"clearIconClass\"\r\n        >\r\n         ${closeFillSVG}\r\n        </span> \r\n    `;\r\n\r\n    /**\r\n     * 渲染带有前缀或者后缀的input的模版\r\n     */\r\n    static innerTemplate: string = `\r\n        <t t-if=\"!hasPrefixSuffix()\">\r\n            <t t-slot=\"default\"/>\r\n        </t>\r\n        <t t-else=\"\">\r\n            <t t-set=\"labeledIconClass\" t-value=\"renderLabeledIconClass()\"/>\r\n                        \r\n            <span t-att-class=\"labeledIconClass.affixWrapperCls\">\r\n                <!--  prefix插槽  -->\r\n                <t t-if=\"props.slots.prefix\">\r\n                    <span t-att-class=\"labeledIconClass.prefixClass\">\r\n                        <t t-slot=\"prefix\"/>\r\n                    </span>\r\n                </t>\r\n                \r\n                <t t-slot=\"default\" />\r\n                \r\n                <!--  suffix插槽  -->\r\n                <t t-if=\"props.slots.suffix || props.allowClear || props.count\">\r\n                    <span t-att-class=\"labeledIconClass.suffixClass\">\r\n                        <t t-if=\"props.allowClear\">\r\n                            ${ClearableLabeledWrapper.clearTemplate}\r\n                        </t>\r\n                        <t t-if=\"props.count\">\r\n                            <span class=\"${showCountSpanClass}\"><t t-esc=\"props.count\"/></span>\r\n                        </t>\r\n                        <t t-slot=\"suffix\"/>\r\n                    </span>\r\n                </t>\r\n            </span>\r\n        </t>\r\n    `;\r\n\r\n    static template: string = xml`\r\n        <t>\r\n            <t t-if=\"props.inputType === 'input'\">\r\n                <t t-if=\"!hasAddon()\">\r\n                    ${ClearableLabeledWrapper.innerTemplate}\r\n                </t>\r\n                \r\n                <t t-else=\"\">\r\n                    <t t-set=\"inputWithLabelClass\" t-value=\"renderInputWithLabelClass()\"/>\r\n                \r\n                    <span t-att-class=\"inputWithLabelClass.mergedGroupClassName\">\r\n                        <span t-att-class=\"inputWithLabelClass.mergedWrapperClassName\">\r\n                            <!--  addonBefore插槽  -->\r\n                            <t t-if=\"props.slots.addonBefore\">\r\n                                <span t-att-class=\"inputWithLabelClass.addonClassName\">\r\n                                    <t t-slot=\"addonBefore\"/>\r\n                                </span>\r\n                            </t>\r\n                            \r\n                            ${ClearableLabeledWrapper.innerTemplate}\r\n                            \r\n                            <!--  addonAfter插槽  -->\r\n                            <t t-if=\"props.slots.addonAfter\">\r\n                                <span t-att-class=\"inputWithLabelClass.addonClassName\">\r\n                                    <t t-slot=\"addonAfter\"/>\r\n                                </span>\r\n                            </t>\r\n                        </span>\r\n                    </span>\r\n                </t>\r\n            </t>\r\n            <t t-else=\"\">\r\n                <t t-if=\"!hasTextSuffix()\">\r\n                    <t t-slot=\"default\"/>\r\n                </t>\r\n                <t t-else=\"\">\r\n                    <t t-set=\"textAreaIconClass\" t-value=\"renderTextAreaWithClearIconClass()\"/>\r\n                    <span t-att-class=\"textAreaIconClass.affixWrapperCls\">\r\n                        <t t-slot=\"default\"/>\r\n                        \r\n                        <t t-set=\"labeledIconClass\" t-value=\"renderLabeledIconClass()\"/>\r\n                        <span t-att-class=\"labeledIconClass.suffixClass\">\r\n                            <t t-if=\"props.allowClear\">\r\n                                ${ClearableLabeledWrapper.clearTemplate}\r\n                            </t>\r\n                            <t t-if=\"props.count\">\r\n                                <span class=\"${showCountSpanClass}\"><t t-esc=\"props.count\"/></span>\r\n                            </t>\r\n                        </span>\r\n                    </span>\r\n                </t>\r\n            </t>\r\n        </t>\r\n    `;\r\n\r\n    static defaultProps = {\r\n        inputType: 'input',\r\n        bordered: true\r\n    };\r\n\r\n    state = useState<State>({});\r\n\r\n    protected hasTextSuffix(): boolean {\r\n        return !!this.props.allowClear || !!this.props.count\r\n    }\r\n\r\n    /**\r\n     * 判断是否有前置、后置部分\r\n     */\r\n    protected hasAddon(): boolean {\r\n        const { slots } = this.props;\r\n        return !!(slots?.addonBefore || slots?.addonAfter);\r\n    }\r\n\r\n    /**\r\n     * 判断是否有前缀、后缀\r\n     */\r\n    protected hasPrefixSuffix(): boolean {\r\n        const { slots } = this.props;\r\n        return !!(slots?.prefix || slots?.suffix || this.props.allowClear || !!this.props.count);\r\n    }\r\n\r\n    /**\r\n     * 清除图标的class\r\n     */\r\n    protected renderClearIconClass(): string | undefined {\r\n        const { value, allowClear, disabled, readOnly, slots } = this.props;\r\n        if (!allowClear) {\r\n            return;\r\n        }\r\n        const needClear = !disabled && !readOnly && value;\r\n        const prefixCls = getPrefixCls('input');\r\n        const className = `${prefixCls}-clear-icon`;\r\n        return classNames(\r\n            {\r\n                [`${className}-hidden`]: !needClear,\r\n                [`${className}-has-suffix`]: !!slots?.suffix\r\n            },\r\n            className\r\n        );\r\n    }\r\n\r\n    /**\r\n     * innerTemplate主区域部分的class\r\n     */\r\n    protected renderLabeledIconClass(): {} {\r\n        const {\r\n            focused,\r\n            value,\r\n            size,\r\n            disabled,\r\n            allowClear,\r\n            direction,\r\n            readOnly,\r\n            bordered,\r\n            slots\r\n        } = this.props;\r\n\r\n        const prefixCls = getPrefixCls('input');\r\n\r\n        const suffixClass = `${prefixCls}-suffix`;\r\n\r\n        const prefixClass = `${prefixCls}-prefix`;\r\n\r\n        const affixWrapperCls = classNames(`${prefixCls}-affix-wrapper`, {\r\n            [`${prefixCls}-affix-wrapper-focused`]: focused,\r\n            [`${prefixCls}-affix-wrapper-disabled`]: disabled,\r\n            [`${prefixCls}-affix-wrapper-sm`]: size === 'small',\r\n            [`${prefixCls}-affix-wrapper-lg`]: size === 'large',\r\n            [`${prefixCls}-affix-wrapper-input-with-clear-btn`]: allowClear && value,\r\n            [`${prefixCls}-affix-wrapper-rtl`]: direction === 'rtl',\r\n            [`${prefixCls}-affix-wrapper-readonly`]: readOnly,\r\n            [`${prefixCls}-affix-wrapper-borderless`]: !bordered\r\n        });\r\n\r\n        const classes = getInputClassName(prefixCls, bordered, size, disabled);\r\n\r\n        return { affixWrapperCls, prefixClass, suffixClass, classes };\r\n    }\r\n\r\n    /**\r\n     * 外部区域的class\r\n     */\r\n    protected renderInputWithLabelClass(): {} {\r\n        const { size, className, direction } = this.props;\r\n        const prefixCls = getPrefixCls('input');\r\n        const wrapperClassName = `${prefixCls}-group`;\r\n        const addonClassName = `${wrapperClassName}-addon`;\r\n\r\n        const mergedWrapperClassName = classNames(`${prefixCls}-wrapper`, wrapperClassName, {\r\n            [`${wrapperClassName}-rtl`]: direction === 'rtl'\r\n        });\r\n\r\n        const mergedGroupClassName = classNames(\r\n            `${prefixCls}-group-wrapper`,\r\n            {\r\n                [`${prefixCls}-group-wrapper-sm`]: size === 'small',\r\n                [`${prefixCls}-group-wrapper-lg`]: size === 'large',\r\n                [`${prefixCls}-group-wrapper-rtl`]: direction === 'rtl'\r\n            },\r\n            className\r\n        );\r\n\r\n        return { addonClassName, mergedWrapperClassName, mergedGroupClassName };\r\n    }\r\n\r\n    /**\r\n     * 文本域带有清除按钮的class\r\n     */\r\n    protected renderTextAreaWithClearIconClass(): {} {\r\n        const { bordered, direction, disabled, allowClear, value } = this.props;\r\n        const prefixCls = getPrefixCls('input');\r\n\r\n        const affixWrapperCls = classNames(\r\n            `${prefixCls}-affix-wrapper`,\r\n            `${prefixCls}-affix-wrapper-textarea`,\r\n            {\r\n                [`${prefixCls}-affix-wrapper-textarea-with-clear-btn`]: allowClear && value,\r\n                [`${prefixCls}-affix-wrapper-disabled`]: disabled,\r\n                [`${prefixCls}-affix-wrapper-rtl`]: direction === 'rtl',\r\n                [`${prefixCls}-affix-wrapper-borderless`]: !bordered\r\n            }\r\n        );\r\n\r\n        return { affixWrapperCls };\r\n    }\r\n}\r\n","import { Component, useEffect, useRef, useState, xml } from '@odoo/owl';\r\nimport ClearableLabeledWrapper from './ClearableLabeledWrapper';\r\nimport { getPrefixCls, omit } from '@/components/_util/utils';\r\nimport classNames from 'classnames';\r\nimport { getInputClassName } from '@/components/input/utils';\r\nimport { SizeType } from '@/components/_util/type';\r\nimport './style/input.scss';\r\nimport useControllableState from '@/hooks/useControllableState';\r\nimport { useImperativeHandle } from '@/hooks/useImperativeHandle';\r\nimport { baseProps, BaseProps } from '@/common/baseProps';\r\n\r\nexport interface IInputFocusOptions extends FocusOptions {\r\n    cursor?: 'start' | 'end' | 'all';\r\n}\r\n\r\nexport function triggerFocus(\r\n    element?: HTMLInputElement | HTMLTextAreaElement | null,\r\n    option?: IInputFocusOptions\r\n): void {\r\n    if (!element) {\r\n        return;\r\n    }\r\n\r\n    element.focus(option);\r\n\r\n    // Selection content\r\n    const { cursor } = option || {};\r\n    if (cursor) {\r\n        const len = element.value.length;\r\n\r\n        switch (cursor) {\r\n            case 'start':\r\n                element.setSelectionRange(0, 0);\r\n                break;\r\n\r\n            case 'end':\r\n                element.setSelectionRange(len, len);\r\n                break;\r\n\r\n            default:\r\n                element.setSelectionRange(0, len);\r\n        }\r\n    }\r\n}\r\n\r\nexport type InputProps = {\r\n    className?: string,\r\n    size?: SizeType,\r\n    disabled?: boolean,\r\n    type?: string,  // input自有type\r\n    maxLength?: number,\r\n    allowClear?: boolean;\r\n    bordered?: boolean;\r\n    placeholder?: string;\r\n    showCount?: boolean;\r\n    defaultValue?: any;\r\n    value?: any;\r\n    onFocus?: (event: any) => void;\r\n    onBlur?: (event: any) => void;\r\n    onChange?: (value: string) => void;\r\n    onInput?: (event: any) => void;\r\n    onPressEnter?: (event: any) => void;\r\n    onKeyDown?: (event: any) => void;\r\n} & BaseProps;\r\n\r\ntype State = {\r\n    focused: boolean;\r\n    count?: string;\r\n    restProps: Record<string, any>\r\n}\r\n\r\nexport default class Input<T extends InputProps> extends Component<T> {\r\n    static props = {\r\n        className: { type: String, optional: true },\r\n        size: { type: String, optional: true },\r\n        disabled: { type: Boolean, optional: true },\r\n        type: { type: String, optional: true },\r\n        maxLength: { type: Number, optional: true },\r\n        allowClear: { type: Boolean, optional: true },\r\n        bordered: { type: Boolean, optional: true },\r\n        placeholder: { type: String, optional: true },\r\n        showCount: { type: Boolean, optional: true },\r\n        defaultValue: { type: String, optional: true },\r\n        value: { type: String, optional: true },\r\n        onFocus: { type: Function, optional: true },\r\n        onBlur: { type: Function, optional: true },\r\n        onChange: { type: Function, optional: true },\r\n        onInput: { type: Function, optional: true },\r\n        onPressEnter: { type: Function, optional: true },\r\n        onKeyDown: { type: Function, optional: true },\r\n        readonly: { type: Boolean, optional: true },\r\n        ...baseProps\r\n    };\r\n\r\n    static components = { ClearableLabeledWrapper };\r\n\r\n    static template = xml`\r\n<ClearableLabeledWrapper className=\"props.className\" inputType=\"'input'\" bordered=\"props.bordered\" size=\"props.size\"\r\n    disabled=\"props.disabled\" focused=\"state.focused\" allowClear=\"props.allowClear\" value=\"controllableState.state.value\"\r\n    handleReset.alike=\"(e) => this.handleReset(e)\" slots=\"props.slots\" count=\"state.count\"\r\n>\r\n    <input \r\n        t-att=\"state.restProps\"\r\n        t-att-disabled=\"props.disabled\"\r\n        t-att-maxlength=\"props.maxLength\"\r\n        t-att-type=\"props.type\"\r\n        t-att-placeholder=\"props.placeholder\"\r\n        t-att-class=\"getClasses()\"\r\n        t-on-focus=\"onFocus\"\r\n        t-on-blur=\"onBlur\"\r\n        t-ref=\"input\"\r\n        t-on-keydown.stop=\"handleKeyDown\"\r\n        t-on-compositionstart=\"onCompositionstart\"\r\n        t-on-compositionend=\"onCompositionend\"\r\n        t-on-input=\"onInput\"\r\n        t-on-change=\"onChange\"\r\n    />\r\n</ClearableLabeledWrapper>\r\n`;\r\n\r\n    inputRef: { el: HTMLInputElement | null } = { el: null };\r\n\r\n    static defaultProps = {\r\n        type: 'text',\r\n        bordered: true\r\n    };\r\n\r\n    // 区分当前是中文输入还是英文输入的flag\r\n    compositionFlag = false;\r\n\r\n    state = useState<State>({\r\n        focused: false,\r\n        count: undefined,\r\n        restProps: {}\r\n    });\r\n\r\n    controllableState = useControllableState(this.props, {\r\n        value: this.props.defaultValue ?? ''\r\n    });\r\n\r\n    protected getClasses(): string {\r\n        const { size, disabled, bordered } = this.props;\r\n        const prefixCls = getPrefixCls('input');\r\n        return classNames(getInputClassName(prefixCls, bordered, size, disabled));\r\n    }\r\n\r\n    protected focus(): void {\r\n        triggerFocus(this.inputRef.el);\r\n        this.state.focused = true;\r\n    }\r\n\r\n    protected onFocus(event: FocusEvent): void {\r\n        const { onFocus } = this.props;\r\n        this.state.focused = true;\r\n        onFocus?.(event);\r\n    }\r\n\r\n    protected blur(): void {\r\n        this.inputRef.el!.blur();\r\n        this.state.focused = false;\r\n    }\r\n\r\n    protected onBlur(event: FocusEvent): void {\r\n        const { onBlur } = this.props;\r\n        this.state.focused = false;\r\n        onBlur?.(event);\r\n    }\r\n\r\n    protected handleKeyDown(e: KeyboardEvent) {\r\n        const { onPressEnter, onKeyDown } = this.props;\r\n        if (onPressEnter && e.key.toLowerCase() === 'enter') {\r\n            onPressEnter(e);\r\n        }\r\n        onKeyDown?.(e);\r\n    };\r\n\r\n    protected onCompositionstart() {\r\n        this.compositionFlag = true;\r\n    };\r\n\r\n    protected onCompositionend(e: Event) {\r\n        this.compositionFlag = false;\r\n        this.onInput(e);\r\n    };\r\n\r\n    protected changeValue(value: string) {\r\n        this.controllableState.setState({ value });\r\n        this.inputRef.el!.value = this.controllableState.state.value;\r\n        this.props.onInput?.(value);\r\n        this.props.onChange?.(value);\r\n    };\r\n\r\n    protected onChange(e: Event) {\r\n        const value = (e.target as HTMLInputElement).value;\r\n        this.props.onChange?.(value);\r\n    }\r\n\r\n    protected onInput(e: Event) {\r\n        if (this.compositionFlag) {\r\n            return;\r\n        }\r\n\r\n        // 设置input的value\r\n        const value = (e.target as HTMLInputElement).value;\r\n        this.changeValue(value);\r\n    };\r\n\r\n    /**\r\n     * 清除输入框\r\n     */\r\n    protected handleReset(): void {\r\n        this.changeValue('');\r\n        triggerFocus(this.inputRef.el);\r\n    };\r\n\r\n    protected getRestProps() {\r\n        return omit(this.props, [\r\n            'className',\r\n            'size',\r\n            'disabled',\r\n            'type',\r\n            'maxLength',\r\n            'allowClear',\r\n            'bordered',\r\n            'placeholder',\r\n            'showCount',\r\n            'defaultValue',\r\n            'value',\r\n            'onFocus',\r\n            'onBlur',\r\n            'onChange',\r\n            'onPressEnter',\r\n            'onKeyDown',\r\n            'slots'\r\n        ]);\r\n    }\r\n\r\n    setup(): void {\r\n        this.inputRef = useRef('input');\r\n\r\n        useImperativeHandle(() => ({\r\n            focus: this.focus.bind(this),\r\n            blur: this.blur.bind(this)\r\n        }), () => []);\r\n\r\n        useEffect(() => {\r\n            this.state.restProps = this.getRestProps();\r\n        }, () => [this.props]);\r\n\r\n        useEffect(() => {\r\n            if (this.inputRef.el) {\r\n                this.inputRef.el!.value = this.controllableState.state.value;\r\n            }\r\n        }, () => [this.inputRef.el]);\r\n\r\n        useEffect(() => {\r\n            this.inputRef.el!.value = this.controllableState.state.value;\r\n            if (this.props.showCount) {\r\n                const value = this.controllableState.state.value;\r\n                this.state.count = this.props.maxLength ? `${value.length}/${this.props.maxLength}` : `${value.length}`;\r\n            } else {\r\n                this.state.count = undefined;\r\n            }\r\n        }, () => [this.props.showCount, this.controllableState.state.value]);\r\n    }\r\n}\r\n","import { useEffect, useState, xml } from '@odoo/owl';\r\nimport Input, { InputProps } from './Input';\r\nimport _eyeSVG from '@/assets/eye.svg';\r\nimport _eyeCloseSVG from '@/assets/eye-close.svg';\r\nimport { getPrefixCls, getSDSVG, omit } from '@/components/_util/utils';\r\nimport classNames from 'classnames';\r\nimport './style/password.scss';\r\nimport useControllableState from '@/hooks/useControllableState';\r\n\r\nconst eyeSVG = getSDSVG(_eyeSVG, {\r\n    width: '1em',\r\n    height: '1em'\r\n});\r\n\r\nconst eyeCloseSVG = getSDSVG(_eyeCloseSVG, {\r\n    width: '1em',\r\n    height: '1em'\r\n});\r\n\r\nexport type PasswordProps = InputProps & {\r\n    visible?: boolean;\r\n    onVisibleChange?: (visible: boolean) => void;\r\n}\r\n\r\ntype State = {\r\n    focused: boolean;\r\n    value: any;\r\n    type: string;\r\n    restProps: {}\r\n}\r\n\r\nconst passwordClass = getPrefixCls('input-password');\r\n\r\nexport default class Password extends Input<PasswordProps> {\r\n    static props = {\r\n        ...Input.props,\r\n        visible: { type: Boolean, optional: true },\r\n        onVisibleChange: { type: Function, optional: true }\r\n    }\r\n\r\n    static template = xml`\r\n <ClearableLabeledWrapper className=\"props.className\" inputType=\"'input'\" bordered=\"props.bordered\" size=\"props.size\"\r\n    disabled=\"props.disabled\" focused=\"state.focused\" allowClear=\"props.allowClear\" value=\"state.value\"\r\n    handleReset.alike=\"(e) => this.handleReset(e)\" slots=\"props.slots\">\r\n    <t t-set-slot=\"suffix\">\r\n        <div t-on-click=\"togglePasswordVisibility\" class=\"${passwordClass}-suffix\">\r\n            <t t-if=\"controllableState.state.visible\">\r\n                ${eyeCloseSVG}\r\n            </t>\r\n            <t t-else=\"\">\r\n                ${eyeSVG}\r\n            </t>\r\n        </div>\r\n    </t>\r\n    \r\n    <input \r\n        t-att=\"state.restProps\"\r\n        t-att-disabled=\"props.disabled\"\r\n        t-att-maxlength=\"props.maxLength\"\r\n        t-att-type=\"state.type\"\r\n        t-att-placeholder=\"props.placeholder\"\r\n        t-att-class=\"getClasses()\"\r\n        t-on-focus.stop=\"onFocus\"\r\n        t-on-blur.stop=\"onBlur\"\r\n        t-ref=\"input\"\r\n        t-on-keydown.stop=\"handleKeyDown\"\r\n        t-model=\"state.value\"\r\n    />\r\n </ClearableLabeledWrapper>   \r\n    `;\r\n\r\n    state = useState<State>({\r\n        focused: false,\r\n        value: '',\r\n        type: 'password',\r\n        restProps: {}\r\n    });\r\n\r\n    controllableState = useControllableState(this.props, {\r\n        visible: false,\r\n        value: this.props.defaultValue || ''\r\n    });\r\n\r\n    protected getClasses(): string {\r\n        return classNames(super.getClasses(), passwordClass);\r\n    }\r\n\r\n    protected togglePasswordVisibility(): void {\r\n        if (!this.props.disabled) {\r\n            this.controllableState.setState({\r\n                visible: !this.controllableState.state.visible\r\n            });\r\n            this.props.onVisibleChange?.(!this.controllableState.state.visible);\r\n        }\r\n    }\r\n\r\n    protected getRestProps() {\r\n        return omit(super.getRestProps(), ['visible', 'onVisibleChange']);\r\n    }\r\n\r\n    public setup(): void {\r\n        super.setup();\r\n        useEffect(() => {\r\n            this.state.type = this.controllableState.state.visible ? 'text' : 'password';\r\n        }, () => [this.controllableState.state.visible]);\r\n    }\r\n}\r\n","import Input, { InputProps } from './Input';\r\nimport { useEffect, useState, xml } from '@odoo/owl';\r\nimport './style/textarea.scss';\r\nimport classNames from 'classnames';\r\nimport { getPrefixCls, omit, stylesToString } from '@/components/_util/utils';\r\nimport { calculateAutoSizeHeight } from '@/components/input/_utils/calculateNodeHeight';\r\n\r\ntype State = {\r\n    style?: string\r\n}\r\n\r\ntype AutoSize = boolean | {\r\n    minRows: number\r\n    maxRows: number\r\n}\r\n\r\nexport type TextAreaProps = Omit<InputProps & {\r\n    rows?: number;\r\n    autoSize?: AutoSize;\r\n    onResize?: (size: { width: number, height: number }) => void;\r\n}, 'slots'>\r\n\r\nconst textareaClass = getPrefixCls('input-textarea');\r\n\r\nexport default class TextArea extends Input<TextAreaProps> {\r\n    static props = {\r\n        ...Input.props,\r\n        rows: { type: Number, optional: true },\r\n        autoSize: { type: [Boolean, Object], optional: true },\r\n        onResize: { type: Function, optional: true }\r\n    };\r\n\r\n    static template = xml`\r\n<ClearableLabeledWrapper className=\"props.className\" inputType=\"'text'\" bordered=\"props.bordered\" size=\"props.size\"\r\n    disabled=\"props.disabled\" focused=\"state.focused\" allowClear=\"props.allowClear\" value=\"controllableState.state.value\"\r\n    handleReset.alike=\"(e) => this.handleReset(e)\" count=\"state.count\"\r\n>\r\n    <textarea\r\n            t-att-style=\"textState.style\"\r\n            t-att=\"state.restProps\"\r\n            t-att-disabled=\"props.disabled\"\r\n            t-att-maxlength=\"props.maxLength\"\r\n            t-att-type=\"props.type\"\r\n            t-att-placeholder=\"props.placeholder\"\r\n            t-att-class=\"getClasses()\"\r\n            t-on-focus.stop=\"onFocus\"\r\n            t-on-blur.stop=\"onBlur\"\r\n            t-ref=\"input\"\r\n            t-on-keydown.stop=\"handleKeyDown\"\r\n            t-on-compositionstart=\"onCompositionstart\"\r\n            t-on-compositionend=\"onCompositionend\"\r\n            t-on-input=\"onInput\"\r\n            t-on-change=\"onChange\"\r\n        />\r\n</ClearableLabeledWrapper>\r\n`;\r\n\r\n    textState = useState<State>({\r\n        style: undefined\r\n    });\r\n\r\n    protected getClasses(): string {\r\n        return classNames(super.getClasses(), textareaClass, {\r\n            [`${textareaClass}-autosize`]: this.props.autoSize\r\n        });\r\n    }\r\n\r\n    protected getRestProps() {\r\n        return omit(super.getRestProps(), ['autoSize', 'onResize']);\r\n    }\r\n\r\n    protected resizeRows() {\r\n        if (!this.props.autoSize) {\r\n            this.textState.style = undefined;\r\n            return;\r\n        }\r\n\r\n        let maxRows = 2;\r\n        let minRows = 2;\r\n        const el = this.inputRef.el!;\r\n        const style = window.getComputedStyle(el);\r\n        const attrs = ['padding-top', 'padding-bottom'];\r\n        const [paddingTop, paddingBottom] = attrs.map(item => style.getPropertyValue(item));\r\n        const lineHeight = parseFloat(style.getPropertyValue('line-height'));\r\n        const rowsHeight = calculateAutoSizeHeight(el as unknown as HTMLTextAreaElement) - parseFloat(\r\n            paddingTop) - parseFloat(paddingBottom);\r\n        const rows = Math.ceil(rowsHeight / lineHeight);\r\n\r\n        if (this.props.autoSize === true) {\r\n            maxRows = Math.max(rows, maxRows);  // 随自身内容高度变化\r\n        } else if (typeof this.props.autoSize === 'object') {\r\n            minRows = this.props.autoSize.minRows;\r\n            maxRows = this.props.autoSize.maxRows;\r\n        }\r\n        const realRows = Math.min(Math.max(rows, minRows), maxRows);\r\n        this.textState.style = stylesToString({\r\n            'height': `${realRows * lineHeight + parseFloat(paddingTop) + parseFloat(paddingBottom)}px`\r\n        });\r\n    }\r\n\r\n    protected changeValue(value: string) {\r\n        super.changeValue(value);\r\n        if (this.props.autoSize) {\r\n            this.resizeRows();\r\n        } else {\r\n            this.textState.style = undefined;\r\n        }\r\n    }\r\n\r\n    setup(): void {\r\n        super.setup();\r\n        useEffect(() => {\r\n            if (this.inputRef.el) {\r\n                const element = this.inputRef.el;\r\n                const resizeObserver = new ResizeObserver((entries) => {\r\n                    const contentBoxSize = entries?.[0].borderBoxSize?.[0];\r\n                    if (contentBoxSize) {\r\n                        this.props.onResize?.({ width: contentBoxSize.inlineSize, height: contentBoxSize.blockSize });\r\n                    }\r\n                });\r\n                resizeObserver.observe(element);\r\n\r\n                return () => {\r\n                    resizeObserver.unobserve(element);\r\n                };\r\n            }\r\n        }, () => [this.inputRef.el]);\r\n\r\n        useEffect(() => {\r\n            if (this.props.autoSize && this.inputRef.el) {\r\n                this.resizeRows();\r\n            }\r\n        }, () => [this.props.autoSize, this.inputRef.el, this.props.size]);\r\n    }\r\n}\r\n","import { Component, useEffect, useState, xml } from '@odoo/owl';\r\nimport Input from '@/components/input/Input';\r\nimport _upSVG from '@/assets/up.svg';\r\nimport _downSVG from '@/assets/down.svg';\r\nimport { getPrefixCls, getSDSVG, omit } from '@/components/_util/utils';\r\nimport './style/input-number.scss';\r\nimport classNames from 'classnames';\r\nimport { CompRef, useImperativeHandle } from '@/hooks/useImperativeHandle';\r\nimport useControllableState from '@/hooks/useControllableState';\r\nimport BigNumber from 'bignumber.js';\r\nimport { BaseProps, baseProps } from '@/common/baseProps';\r\nimport { SizeType } from '@/components/_util/type';\r\n\r\nconst inputNumberWrapClass = getPrefixCls('input-number-wrap');\r\nconst inputNumberClass = getPrefixCls('input-number');\r\nconst iconClass = getPrefixCls('input-number-icon');\r\nconst numberHandlerWrapClass = getPrefixCls('input-number-handler-wrap');\r\n\r\nconst upSVG = getSDSVG(_upSVG, {\r\n    width: '1em',\r\n    height: '1em'\r\n});\r\n\r\nconst downSVG = getSDSVG(_downSVG, {\r\n    width: '1em',\r\n    height: '1em'\r\n});\r\n\r\ntype Props = {\r\n    className?: string;\r\n    step?: number;\r\n    defaultValue?: number;\r\n    value?: number;\r\n    size?: SizeType;\r\n    onFocus?: (event: FocusEvent) => void;\r\n    onBlur?: (event: FocusEvent) => void;\r\n    onChange?: (value: number | string) => void;\r\n    max?: number;\r\n    min?: number;\r\n    placeholder?: string;\r\n    disabled?: boolean;\r\n    bordered?: boolean;\r\n    autoFocus?: boolean;\r\n    changeOnBlur?: boolean;\r\n    controls?: boolean;\r\n    decimalSeparator?: string;\r\n    precision?: number;\r\n    formatter?: (value: string) => string;\r\n    parser?: (value: string) => string;\r\n    keyboard?: boolean;\r\n    readonly?: boolean;\r\n    stringMode?: boolean;\r\n    onPressEnter?: (event: Event) => void;\r\n    onStep?: (value: number, info: { offset: number; type: 'up' | 'down' }) => void;\r\n} & BaseProps;\r\n\r\ntype State = {\r\n    focused: boolean;\r\n}\r\n\r\nclass InputNumber extends Component<Props, State> {\r\n    static props = {\r\n        className: { type: String, optional: true },\r\n        step: { type: Number, optional: true },\r\n        defaultValue: { type: Number, optional: true },\r\n        value: { type: Number, optional: true },\r\n        size: { type: String, optional: true },\r\n        onFocus: { type: Function, optional: true },\r\n        onBlur: { type: Function, optional: true },\r\n        onChange: { type: Function, optional: true },\r\n        max: { type: Number, optional: true },\r\n        min: { type: Number, optional: true },\r\n        placeholder: { type: String, optional: true },\r\n        disabled: { type: Boolean, optional: true },\r\n        bordered: { type: Boolean, optional: true },\r\n        autoFocus: { type: Boolean, optional: true },\r\n        changeOnBlur: { type: Boolean, optional: true },\r\n        controls: { type: Boolean, optional: true },\r\n        decimalSeparator: { type: String, optional: true },\r\n        precision: { type: Number, optional: true },\r\n        formatter: { type: Function, optional: true },\r\n        parser: { type: Function, optional: true },\r\n        keyboard: { type: Boolean, optional: true },\r\n        readonly: { type: Boolean, optional: true },\r\n        stringMode: { type: Boolean, optional: true },\r\n        onPressEnter: { type: Function, optional: true },\r\n        onStep: { type: Function, optional: true },\r\n        ...baseProps\r\n    };\r\n\r\n    static defaultProps = {\r\n        autoFocus: false,\r\n        changeOnBlur: true,\r\n        controls: true,\r\n        keyboard: true,\r\n        step: 1,\r\n        max: Number.MAX_SAFE_INTEGER,\r\n        min: Number.MIN_SAFE_INTEGER\r\n    };\r\n\r\n    static components = { Input };\r\n\r\n    static inputTemplate = `\r\n<span t-att-class=\"getClasses()\">\r\n    <Input className=\"\" ref=\"inputRef\" onFocus.bind=\"onFocus\" onBlur.bind=\"onBlur\" \r\n        onKeyDown.bind=\"onKeyDown\"\r\n        placeholder=\"props.placeholder\"\r\n        readonly=\"props.readonly\"\r\n        onPressEnter=\"props.onPressEnter\"\r\n        value=\"controllableState.state.value\" onChange.bind=\"onchangeValue\"\r\n        disabled=\"props.disabled\"\r\n        size=\"props.size\"\r\n        bordered=\"false\"\r\n        slots=\"filterSlots('ix')\"\r\n    />\r\n    <t t-if=\"showControls()\">\r\n        <t t-set=\"iconClass\" t-value=\"renderIconClasses()\"/>\r\n        <span class=\"${numberHandlerWrapClass}\" t-ref=\"handlerRef\" t-on-click=\"onClickWrap\">\r\n            <span t-att-class=\"iconClass.increase\" t-on-click=\"(event) => this.onStep('up', event)\">\r\n                <t t-slot=\"upIcon\">\r\n                    ${upSVG}\r\n                </t>\r\n            </span>\r\n            <span t-att-class=\"iconClass.decrease\" t-on-click=\"(event) => this.onStep('down', event)\">\r\n                <t t-slot=\"downIcon\">\r\n                    ${downSVG}\r\n                </t>\r\n            </span>\r\n        </span>\r\n    </t>    \r\n</span>\r\n`;\r\n\r\n    static template = xml`\r\n<t t-if=\"hasAddon()\">\r\n    <span class=\"${inputNumberWrapClass}\">\r\n        <t t-if=\"props.slots.addonBefore\">\r\n            <span class=\"${inputNumberWrapClass}-addon ${inputNumberClass}-addon-before\">\r\n                <t t-slot=\"addonBefore\"/>\r\n            </span>\r\n        </t>\r\n        ${InputNumber.inputTemplate}\r\n        <t t-if=\"props.slots.addonAfter\">\r\n            <span class=\"${inputNumberWrapClass}-addon ${inputNumberClass}-prefix\">\r\n                <t t-slot=\"addonAfter\"/>\r\n            </span>\r\n        </t>\r\n    </span>\r\n</t>\r\n<t t-else=\"\">\r\n    ${InputNumber.inputTemplate}\r\n</t>\r\n    `;\r\n\r\n    state = useState<State>({\r\n        focused: false\r\n    });\r\n\r\n    controllableState = useControllableState(this.props, {\r\n        value: this.props.defaultValue ? this.precisionValue(BigNumber(this.props.defaultValue)) : ''\r\n    }, (val) => `${val}`);\r\n\r\n    inputRef: CompRef = { current: undefined };\r\n\r\n    /**\r\n     * 判断是否有前置、后置部分\r\n     */\r\n    protected hasAddon(): boolean {\r\n        const { slots } = this.props;\r\n        return !!(slots?.addonBefore || slots?.addonAfter);\r\n    }\r\n\r\n    /**\r\n     * 过滤掉slots\r\n     * @param type 如果是addon，则过滤掉suffix、prefix，如果是ix，则过滤掉addonBefore、addonAfter\r\n     * @protected\r\n     */\r\n    protected filterSlots(type: 'addon' | 'ix') {\r\n        if (this.props.slots) {\r\n            return omit(this.props.slots, type === 'addon' ? ['suffix', 'prefix'] : ['addonBefore', 'addonAfter']);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 是否显示加减按钮\r\n     * @protected\r\n     */\r\n    protected showControls(): boolean {\r\n        return !!this.props.controls && !this.props.disabled;\r\n    }\r\n\r\n    protected focus(): void {\r\n        this.state.focused = true;\r\n    }\r\n\r\n    /**\r\n     * 获取焦点回调\r\n     * @param event\r\n     * @protected\r\n     */\r\n    protected onFocus(event: FocusEvent): void {\r\n        this.focus();\r\n        const { onFocus } = this.props;\r\n        onFocus?.(event);\r\n    }\r\n\r\n    protected blur(): void {\r\n        const { changeOnBlur } = this.props;\r\n        this.state.focused = false;\r\n        if (changeOnBlur) {\r\n            this.onchangeValue(this.getValueNotOutOfRange(this.controllableState.state.value));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 失去焦点回调，如果changeOnBlur为true，则在失去焦点时触发onChange\r\n     * @param event\r\n     * @protected\r\n     */\r\n    protected onBlur(event: FocusEvent): void {\r\n        this.blur();\r\n        const { onBlur, changeOnBlur } = this.props;\r\n        onBlur?.(event);\r\n    }\r\n\r\n    /**\r\n     * 键盘按下回调，如果keyboard为true，则可以使用上下键控制数字增减\r\n     * @param event\r\n     * @protected\r\n     */\r\n    protected onKeyDown(event: KeyboardEvent): void {\r\n        const { keyboard } = this.props;\r\n        if (keyboard) {\r\n            switch (event.key.toLowerCase()) {\r\n                case 'arrowup':\r\n                    event.preventDefault();\r\n                    this.increaseOrDecrease(true, event);\r\n                    break;\r\n                case 'arrowdown':\r\n                    event.preventDefault();\r\n                    this.increaseOrDecrease(false, event);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 点击加减按钮回调\r\n     * @param type up为加，down为减\r\n     * @param event\r\n     * @protected\r\n     */\r\n    protected onStep(type: 'up' | 'down', event: Event): void {\r\n        const { onStep } = this.props;\r\n        const oldValue = this.controllableState.state.value;\r\n        this.increaseOrDecrease(type === 'up', event);\r\n        onStep?.(Number(oldValue), { offset: this.props.step as number, type });\r\n    }\r\n\r\n    /**\r\n     * 点击外层wrap回调，聚焦input\r\n     * @protected\r\n     */\r\n    protected onClickWrap(): void {\r\n        this.inputRef.current?.focus();\r\n    }\r\n\r\n    /**\r\n     * 精确数字小数点并返回对应的字符串\r\n     * @param bn 值的BigNumber实例\r\n     * @protected\r\n     */\r\n    protected precisionValue(bn: BigNumber): string {\r\n        const { precision } = this.props;\r\n        return precision ? bn.toFixed(precision) : bn.toFixed();\r\n    }\r\n\r\n    /**\r\n     * 输入框值改变回调\r\n     * @param value\r\n     * @protected\r\n     */\r\n    protected onchangeValue(value: string): void {\r\n        const { stringMode } = this.props;\r\n        let stringValue = value;\r\n        if (value !== '') {\r\n            let bn = BigNumber(this.parse(value));\r\n            bn = bn.isNaN() ? BigNumber('0') : bn;\r\n            stringValue = this.precisionValue(bn);\r\n        }\r\n\r\n        this.controllableState.setState({\r\n            value: this.formatValue(stringValue)\r\n        });\r\n        this.props.onChange?.(stringMode ? stringValue : Number(stringValue));\r\n    }\r\n\r\n    /**\r\n     * 获取不超出范围的值，根据value值和max、min值判断\r\n     * @param value\r\n     * @protected\r\n     */\r\n    protected getValueNotOutOfRange(value: string): string {\r\n        if (value === '') {\r\n            return '';\r\n        }\r\n\r\n        const { max, min } = this.props;\r\n        let bn = BigNumber(value);\r\n        const v = bn.isNaN() ? BigNumber('0') : bn;\r\n        if (v.isNaN() || v.isGreaterThan(max!)) {\r\n            return max!.toString();\r\n        }\r\n        if (v.isNaN() || v.isLessThan(min!)) {\r\n            return min!.toString();\r\n        }\r\n        return v.toFixed();\r\n    }\r\n\r\n    /**\r\n     * 是否允许增加或减少\r\n     * @param isIncrease 加true，减false\r\n     * @protected\r\n     */\r\n    protected enableIncreaseOrDecrease(isIncrease: boolean): boolean {\r\n        const { min, max } = this.props;\r\n        const { value } = this.controllableState.state;\r\n        const bn = BigNumber(value || '0');\r\n\r\n        if (isIncrease && max !== undefined) {\r\n            return bn.isLessThan(max);\r\n        }\r\n        if (!isIncrease && min !== undefined) {\r\n            return bn.isGreaterThan(min);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 增加或减少value值\r\n     * @param isIncrease 加true，减false\r\n     * @param event\r\n     * @protected\r\n     */\r\n    protected increaseOrDecrease(isIncrease: boolean, event: Event): void {\r\n        event?.stopPropagation();\r\n        event?.preventDefault();\r\n        if (!this.enableIncreaseOrDecrease(isIncrease)) {\r\n            return;\r\n        }\r\n\r\n        const { step } = this.props;\r\n        const { value } = this.controllableState.state;\r\n        const bn = BigNumber(value || '0');\r\n        const newValue = isIncrease ? bn.plus(step as number) : bn.minus(step as number);\r\n        this.onchangeValue(this.getValueNotOutOfRange(newValue.toFixed()));\r\n    }\r\n\r\n    protected getClasses() {\r\n        return classNames(inputNumberClass, this.props.className, {\r\n            [`${inputNumberClass}-focused`]: this.state.focused,\r\n            [`${inputNumberClass}-disabled`]: !!this.props.disabled,\r\n            [`${inputNumberClass}-borderless`]: this.props.bordered === false\r\n        });\r\n    }\r\n\r\n    protected renderIconClasses() {\r\n        return {\r\n            increase: classNames(iconClass, {\r\n                [`${iconClass}-disabled`]: !this.enableIncreaseOrDecrease(true)\r\n            }),\r\n            decrease: classNames(iconClass, {\r\n                [`${iconClass}-disabled`]: !this.enableIncreaseOrDecrease(false)\r\n            })\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 格式化value值，如果有formatter，则使用formatter格式化\r\n     * @param value\r\n     * @protected\r\n     */\r\n    protected formatValue(value: string): string {\r\n        const { decimalSeparator, formatter } = this.props;\r\n        if (decimalSeparator) {\r\n            // 替换.为decimalSeparator\r\n            value = value.replace(/\\./g, decimalSeparator);\r\n        }\r\n        if (formatter) {\r\n            value = formatter(value);\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * 解析value值，如果有parser，则使用parser解析\r\n     * @param value\r\n     * @protected\r\n     */\r\n    protected parse(value: string): string {\r\n        const { decimalSeparator, parser } = this.props;\r\n        if (decimalSeparator) {\r\n            // 替换decimalSeparator为. decimalSeparator可能为.或者其他\r\n            value = value.replace(new RegExp(decimalSeparator.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'g'), '.');\r\n        }\r\n        if (parser) {\r\n            value = parser(value);\r\n        }\r\n        return value;\r\n    }\r\n\r\n    setup(): void {\r\n        useImperativeHandle(() => ({\r\n            focus: this.focus.bind(this),\r\n            blur: this.blur.bind(this)\r\n        }), () => []);\r\n\r\n        useEffect(() => {\r\n            if (this.props.autoFocus) {\r\n                this.inputRef.current?.focus();\r\n            }\r\n        }, () => [this.inputRef.current]);\r\n    }\r\n}\r\n\r\nexport default InputNumber;\r\n","import { Component, xml } from '@odoo/owl';\r\n\r\ntype Props = {\r\n\r\n}\r\n\r\nclass Item extends Component<Props>{\r\n    static template = xml`\r\n<div>\r\n    sasdf\r\n</div>    \r\n`\r\n}\r\n\r\nexport default Item;\r\n","import { Component, useEffect, useRef, useState, xml } from '@odoo/owl';\r\nimport { useSize } from '@/hooks/useSize';\r\nimport { isNumber } from '@/components/_util';\r\nimport { getPrefixCls, stylesToString } from '@/components/_util/utils';\r\nimport { useEventListener } from '@/hooks/useEventListener';\r\nimport { useImperativeHandle } from '@/hooks/useImperativeHandle';\r\nimport { baseProps, BaseProps } from '@/common/baseProps';\r\nimport { MouseEvent } from 'react';\r\nimport classNames from 'classnames';\r\n\r\nexport type ItemHeight = (index: number, data: any) => number;\r\n\r\nexport type Position = 'start' | 'end' | 'mid';\r\n\r\nexport type OnRender = () => void;\r\n\r\ntype Props = {\r\n    className?: string,\r\n    list: any[],\r\n    height?: number,\r\n    itemHeight: number | ItemHeight,\r\n    overscan?: number,\r\n    onScroll?: (event: MouseEvent, position: Position) => void,\r\n    onRendered?: OnRender\r\n} & BaseProps;\r\n\r\ntype TargetData = {\r\n    index: number,\r\n    data: any\r\n}\r\n\r\ntype State = {\r\n    renderTriggerByEffect: boolean,\r\n    scrollTriggerByScrollToFunc: boolean,\r\n    targetList: TargetData[],\r\n    wrapperStyle?: string,\r\n    containerHeight: number\r\n}\r\n\r\nconst VirtualListClass = getPrefixCls('vir-list');\r\nconst VirtualListWrapperClass = getPrefixCls('vir-list-wrapper');\r\n\r\nclass VirtualList extends Component<Props> {\r\n    static props = {\r\n        className: { type: String, optional: true },\r\n        list: { type: Array },\r\n        height: { type: Number, optional: true },\r\n        itemHeight: { type: [Number, Function] },\r\n        overscan: { type: Number, optional: true },\r\n        onScroll: { type: Function, optional: true },\r\n        onRendered: { type: Function, optional: true },\r\n        ...baseProps\r\n    };\r\n\r\n    static defaultProps = {\r\n        overscan: 5\r\n    };\r\n\r\n    static template = xml`\r\n<div t-att-class=\"getClass()\" t-ref=\"container\" t-att-style=\"getStyle()\">\r\n    <div t-ref=\"wrapper\" t-att-style=\"state.wrapperStyle\" class=\"${VirtualListWrapperClass}\">\r\n        <t t-foreach=\"state.targetList\" t-as=\"target\" t-key=\"target.index\">\r\n            <t t-slot=\"item\" data=\"target.data\" index=\"target.index\" style=\"target.style\"/>\r\n        </t>\r\n    </div>\r\n</div>   \r\n    `;\r\n\r\n    containerRef = useRef<HTMLDivElement>('container');\r\n    wrapperRef = useRef<HTMLDivElement>('wrapper');\r\n    size = useSize('container');\r\n\r\n    state = useState<State>({\r\n        renderTriggerByEffect: false,\r\n        scrollTriggerByScrollToFunc: false,\r\n        targetList: [],\r\n        wrapperStyle: undefined,\r\n        containerHeight: 0\r\n    });\r\n\r\n    protected getClass() {\r\n        return classNames(VirtualListClass, this.props.className);\r\n    }\r\n\r\n    protected getStyle() {\r\n        const { height } = this.props;\r\n        const style = {\r\n            overflow: 'auto',\r\n            'overflow-anchor': 'none'\r\n        };\r\n        // 如果有指定高度，则设置max-height，否则height设为100%\r\n        // max-height可以达到在不需要滚动时，高度自适应的效果\r\n        if (isNumber(height)) {\r\n            style['max-height'] = `${height}px`;\r\n        } else {\r\n            style['height'] = '100%';\r\n        }\r\n        return stylesToString(style);\r\n    }\r\n\r\n    protected getTotalHeight() {\r\n        const { itemHeight } = this.props;\r\n        if (isNumber(itemHeight)) {\r\n            // 如果是固定高度，则直接计算\r\n            return this.props.list.length * itemHeight;\r\n        }\r\n        let sum = 0;\r\n        for (let i = 0; i < this.props.list.length; i++) {\r\n            const item = this.props.list[i];\r\n            const height = itemHeight(i, item);\r\n            sum += height;\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    /**\r\n     * 获取当前的数据偏移量，注：指向的下一个数据索引\r\n     * @param scrollTop 滚动条距离顶部的距离\r\n     * @protected\r\n     */\r\n    protected getOffset(scrollTop: number): number {\r\n        const { itemHeight } = this.props;\r\n        if (isNumber(itemHeight)) {\r\n            // 如果是固定高度，则直接计算\r\n            return Math.ceil(scrollTop / itemHeight);\r\n        }\r\n\r\n        let sum = 0;\r\n        let offset = 0;\r\n        for (let i = 0; i < this.props.list.length; i++) {\r\n            const item = this.props.list[i];\r\n            const height = itemHeight(i, item);\r\n            sum += height;\r\n            if (sum >= scrollTop) {\r\n                offset = i;\r\n                break;\r\n            }\r\n        }\r\n        return offset + 1;\r\n    }\r\n\r\n    /**\r\n     * 获取可视区域内的数据数量\r\n     * @param clientHeight\r\n     * @param fromIndex\r\n     * @protected\r\n     */\r\n    protected getVisibleCount(clientHeight: number, fromIndex: number): number {\r\n        const { itemHeight } = this.props;\r\n        if (isNumber(itemHeight)) {\r\n            // 如果是固定高度，则直接计算\r\n            return Math.ceil(clientHeight / itemHeight);\r\n        }\r\n        let sum = 0;\r\n        let endIndex = 0;\r\n        for (let i = fromIndex; i < this.props.list.length; i++) {\r\n            const item = this.props.list[i];\r\n            const height = itemHeight(i, item);\r\n            sum += height;\r\n            endIndex = i;\r\n            if (sum >= clientHeight) {\r\n                break;\r\n            }\r\n        }\r\n        return endIndex - fromIndex;\r\n    }\r\n\r\n    /**\r\n     * 计算指定索引的数据距离顶部的距离\r\n     * @param index\r\n     * @protected\r\n     */\r\n    protected getDistanceTop(index: number): number {\r\n        const { itemHeight } = this.props;\r\n        if (isNumber(itemHeight)) {\r\n            // 如果是固定高度，则直接计算\r\n            return index * itemHeight;\r\n        }\r\n        let sum = 0;\r\n        for (let i = 0; i < index; i++) {\r\n            const item = this.props.list[i];\r\n            const height = itemHeight(i, item);\r\n            sum += height;\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    /**\r\n     * 计算可视区域内的数据\r\n     * @protected\r\n     */\r\n    protected calculateRange() {\r\n        const { overscan, itemHeight } = this.props;\r\n        const container = this.containerRef.el;\r\n        if (container) {\r\n            const { scrollTop, clientHeight } = container;\r\n            const offset = this.getOffset(scrollTop);\r\n            const visibleCount = this.getVisibleCount(clientHeight, offset);\r\n            const start = Math.max(0, offset - overscan!);\r\n            const end = Math.min(this.props.list.length, offset + visibleCount + overscan!);\r\n            const offsetTop = this.getDistanceTop(start);\r\n            const totalHeight = this.getTotalHeight();\r\n            this.state.containerHeight = clientHeight;\r\n            this.state.wrapperStyle = stylesToString({\r\n                height: `${totalHeight - offsetTop}px`,\r\n                'margin-top': `${offsetTop}px`\r\n            });\r\n            this.state.targetList = this.props.list.slice(start, end).map((data, index) => ({\r\n                index: start + index,\r\n                data,\r\n                style: stylesToString({\r\n                    height: isNumber(itemHeight) ? `${itemHeight}px` : `${itemHeight(start + index, data)}px`\r\n                })\r\n            }));\r\n        }\r\n    }\r\n\r\n    protected scrollTo(index: number) {\r\n        if (this.containerRef.el) {\r\n            this.state.scrollTriggerByScrollToFunc = true;\r\n            this.containerRef.el.scrollTop = this.getDistanceTop(index);\r\n            this.calculateRange();\r\n        }\r\n    };\r\n\r\n    public setup(): void {\r\n        useImperativeHandle(() => ({\r\n            scrollTo: this.scrollTo.bind(this)\r\n        }), () => [this.props]);\r\n\r\n        useEventListener(this.containerRef, 'scroll', (event: MouseEvent) => {\r\n            if (this.state.scrollTriggerByScrollToFunc) {\r\n                // 如果是 scrollTo 方法触发的滚动，则不再触发计算\r\n                this.state.scrollTriggerByScrollToFunc = false;\r\n                return;\r\n            }\r\n            event.preventDefault();\r\n            this.calculateRange();\r\n            let position: Position = 'mid';\r\n            if (event.currentTarget.scrollTop === 0) {\r\n                position = 'start';\r\n            } else if (event.currentTarget.scrollHeight - event.currentTarget.scrollTop === this.state.containerHeight) {\r\n                // 可滚动总高度 - 滚动条距离顶部的距离 和 容器高度相等表示滚动到底部\r\n                position = 'end';\r\n            }\r\n\r\n            this.props.onScroll?.(event, position);\r\n        });\r\n\r\n        useEffect(() => {\r\n            if (this.state.renderTriggerByEffect) {\r\n                // 仅在受effect触发时才触发onRendered\r\n                this.props.onRendered?.();\r\n            }\r\n            this.state.renderTriggerByEffect = false;\r\n\r\n        }, () => [this.state.targetList]);\r\n\r\n        useEffect(() => {\r\n            this.state.renderTriggerByEffect = true;\r\n            this.calculateRange();\r\n        }, () => [this.size.width, this.size.height, this.props.list]);\r\n    }\r\n}\r\n\r\nexport default VirtualList;\r\n","import { Component, useState, xml } from '@odoo/owl';\r\nimport Item from '@/components/list/Item';\r\nimport VirtualList, { ItemHeight, OnRender, Position } from '@/components/list/VirtualList';\r\nimport classNames from 'classnames';\r\nimport _emptySVG from '@/assets/empty.svg';\r\nimport { getPrefixCls, getSDSVG } from '@/components/_util/utils';\r\nimport { baseProps, BaseProps } from '@/common/baseProps';\r\nimport './style/list.scss';\r\nimport { SizeType } from '@/components/_util/type';\r\nimport { useCompRef, useImperativeHandle } from '@/hooks/useImperativeHandle';\r\n\r\nconst emptySVG = getSDSVG(_emptySVG, {\r\n    width: '64',\r\n    height: '41'\r\n});\r\n\r\ntype Props = {\r\n    size?: SizeType,\r\n    bordered?: boolean, // 是否有边框\r\n    className?: string, // 类名\r\n    itemClassName?: (item: any, index: number) => string, // 每一项的类名\r\n    dataSource: any[], // 数据源\r\n    virtual?: boolean, // 是否开启虚拟列表\r\n    height?: number, // virtual为true时设置，列表的高度，如果不设置则为container高度的100%\r\n    itemHeight?: number | ItemHeight, // virtual为true时设置，每一项的高度\r\n    onScroll?: (event: MouseEvent, position: Position) => void // virtual为true时设置，滚动时触发\r\n    onRendered?: OnRender // virtual为true时设置，渲染完成时触发\r\n} & BaseProps;\r\n\r\nconst listClass = getPrefixCls('list');\r\nconst listHeadClass = getPrefixCls('list-head');\r\nconst listContainerClass = getPrefixCls('list-container');\r\nconst listFooterClass = getPrefixCls('list-footer');\r\nconst listItemClass = getPrefixCls('list-item');\r\nconst vrListItemClass = getPrefixCls('vr-list-item');\r\n\r\nclass List extends Component<Props> {\r\n    static components = { Item, VirtualList };\r\n\r\n    static props = {\r\n        className: { type: String, optional: true },\r\n        itemClassName: { type: Function, optional: true },\r\n        bordered: { type: Boolean, optional: true },\r\n        size: { type: String, optional: true },\r\n        dataSource: { type: Array, optional: true },\r\n        virtual: { type: Boolean, optional: true },\r\n        height: { type: Number, optional: true },\r\n        itemHeight: { type: [Number, Function], optional: true },\r\n        onScroll: { type: Function, optional: true },\r\n        onRendered: { type: Function, optional: true },\r\n        ...baseProps\r\n    };\r\n\r\n    static defaultProps = {\r\n        dataSource: [],\r\n        bordered: false\r\n    };\r\n\r\n    static template = xml`\r\n<div t-att-class=\"getClasses()\">\r\n    <t t-if=\"hasHeader()\">\r\n        <div class=\"${listHeadClass}\">\r\n            <t t-slot=\"header\"/>\r\n        </div>\r\n    </t>\r\n    \r\n    <div class=\"${listContainerClass}\">\r\n        <t t-if=\"showItems()\">\r\n            <t t-if=\"props.virtual\">\r\n                <VirtualList ref=\"virRef\" onScroll=\"props.onScroll\" onRendered=\"props.onRendered\" list=\"props.dataSource\" itemHeight=\"props.itemHeight\" height=\"props.height\">\r\n                    <t t-set-slot=\"item\" t-slot-scope=\"scope\">\r\n                        <div t-att-class=\"getItemClasses(scope.data, scope.index)\" t-att-style=\"scope.style\">\r\n                            <t t-slot=\"item\" t-props=\"scope\"/>\r\n                        </div>\r\n                    </t>\r\n                </VirtualList>\r\n            </t>\r\n            <div t-else=\"\" t-att-class=\"getItemClasses(item, item_index)\" t-foreach=\"props.dataSource\" t-as=\"item\" t-key=\"item_index\">\r\n                <t t-slot=\"item\" data=\"item\" index=\"item_index\"/>\r\n            </div>\r\n        </t>\r\n    </div>\r\n    \r\n    <t t-if=\"hasFooter()\">\r\n        <div class=\"${listFooterClass}\">\r\n            <t t-slot=\"footer\"/>\r\n        </div>\r\n    </t>\r\n</div>   \r\n    `;\r\n\r\n    state = useState({});\r\n    virRef = useCompRef();\r\n\r\n    protected hasHeader() {\r\n        return !!this.props.slots?.header;\r\n    }\r\n\r\n    protected hasFooter() {\r\n        return !!this.props.slots?.footer;\r\n    }\r\n\r\n    protected showItems() {\r\n        return !!this.props.slots?.item;\r\n    }\r\n\r\n    protected getClasses() {\r\n        const { className, bordered, size, virtual } = this.props;\r\n        const hasAnySlot = this.hasFooter() || this.hasHeader() || this.showItems();\r\n\r\n        return classNames(className, listClass, {\r\n            [`${listClass}-borderless`]: !bordered || !hasAnySlot,\r\n            [`${listClass}-sm`]: size === 'small',\r\n            [`${listClass}-lg`]: size === 'large',\r\n            [`${listClass}-vt`]: !!virtual\r\n        });\r\n    }\r\n\r\n    protected getItemClasses(item: any, index: number) {\r\n        return classNames(listItemClass, this.props.itemClassName?.(item, index), {\r\n            [vrListItemClass]: !!this.props.virtual\r\n        });\r\n    }\r\n\r\n    public setup(): void {\r\n        useImperativeHandle(() => ({\r\n            scrollTo: (index: number) => this.virRef.current?.scrollTo(index)\r\n        }), () => []);\r\n    }\r\n}\r\n\r\nexport default List;\r\n","import { Component, useEffect, useRef, useState, xml } from '@odoo/owl';\r\nimport { getPrefixCls, stylesToString } from '@/components/_util/utils';\r\nimport { baseProps, BaseProps } from '@/common/baseProps';\r\nimport classNames from 'classnames';\r\nimport domAlign from 'dom-align';\r\nimport './style/trigger.scss';\r\nimport { useImperativeHandle } from '@/hooks/useImperativeHandle';\r\nimport { useEventListener } from '@/hooks/useEventListener';\r\n\r\nexport type Placement = 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';\r\n\r\ntype Props = {\r\n    placement: Placement\r\n    className?: string;\r\n    isOpen: boolean;  // 是否显示\r\n    destroyOnHide?: boolean;  // 隐藏时销毁\r\n    triggerNode?: HTMLElement;  // 触发节点\r\n    getPopupContainer?: (triggerNode?: HTMLElement) => string; // 返回一个选择器字符串\r\n    getStyle?: (triggerNode?: HTMLElement) => string; // 返回一个样式字符串\r\n    onScroll?: (event: MouseEvent) => void;\r\n} & BaseProps;\r\n\r\nconst triggerClass = getPrefixCls('trigger');\r\nconst triggerHiddenClass = getPrefixCls('trigger-hidden');\r\n\r\n// 用第二个参数的位置去对齐第一个参数的位置\r\nconst placementMap: Record<Placement, [string, string]> = {\r\n    topLeft: ['bl', 'tl'],\r\n    topRight: ['br', 'tr'],\r\n    bottomLeft: ['tl', 'bl'],\r\n    bottomRight: ['tr', 'br']\r\n};\r\n\r\n// 第一个参数是sourceNode的x轴偏移量，第二个参数是sourceNode的y轴偏移量\r\nconst placementOffsetMap: Record<Placement, [number, number]> = {\r\n    topLeft: [0, -4],\r\n    topRight: [0, -4],\r\n    bottomLeft: [0, 4],\r\n    bottomRight: [0, 4]\r\n};\r\n\r\nclass Trigger extends Component<Props> {\r\n    static props = {\r\n        className: { type: String, optional: true },\r\n        placement: { type: String },\r\n        isOpen: { type: Boolean },\r\n        destroyOnHide: { type: Boolean, optional: true },\r\n        triggerNode: { type: Object, optional: true },\r\n        getPopupContainer: { type: Function, optional: true },\r\n        getStyle: { type: Function, optional: true },\r\n        onScroll: { type: Function, optional: true },\r\n        ...baseProps\r\n    };\r\n\r\n    static defaultProps = {\r\n        destroyOnHide: false\r\n    };\r\n\r\n    static contentTemplate = `\r\n<div t-ref=\"wrapperRef\" t-att-class=\"getClass()\" t-portal=\"getPopupContainer()\" t-att-style=\"getStyle()\">\r\n    <t t-slot=\"default\"/>\r\n</div>  \r\n    `;\r\n\r\n    static template = xml`\r\n<t>\r\n    <t t-if=\"!props.destroyOnHide\">\r\n        ${Trigger.contentTemplate}\r\n    </t>\r\n    <t t-else=\"\">\r\n        <t t-if=\"state.isShow\">\r\n            ${Trigger.contentTemplate}\r\n        </t>\r\n    </t>\r\n</t>\r\n    `;\r\n\r\n    wrapperRef = useRef('wrapperRef');\r\n\r\n    state = useState({\r\n        isShow: false // 用于控制隐藏时销毁\r\n    });\r\n\r\n    lastIsOpen = false;  // 最后一次是打开还是关闭，用来控制是否需要展示fade动画，因为第一次打开始终需要展示动画\r\n\r\n    protected getClass() {\r\n        const { className, isOpen } = this.props;\r\n        const notShowFade = isOpen && this.lastIsOpen;\r\n        return classNames(triggerClass, className, {\r\n            [`${triggerClass}-${isOpen ? 'fadein' : 'fadeout'}`]: !notShowFade\r\n        });\r\n    }\r\n\r\n    protected getPopupContainer(): string {\r\n        return this.props.getPopupContainer?.(this.props.triggerNode) || 'body';\r\n    }\r\n\r\n    protected getStyle() {\r\n        // 初始状态强制设置为隐藏\r\n        if (!this.props.triggerNode) {\r\n            return stylesToString({\r\n                'display': 'none'\r\n            });\r\n        }\r\n        return this.props.getStyle?.(this.props.triggerNode) || undefined;\r\n    }\r\n\r\n    /**\r\n     * 对齐\r\n     * @protected\r\n     */\r\n    protected align() {\r\n        const { triggerNode, placement } = this.props;\r\n        if (this.wrapperRef.el && triggerNode) {\r\n            const alignConfig = {\r\n                points: placementMap[placement],\r\n                offset: placementOffsetMap[placement],\r\n                targetOffset: ['0', '0'] // 同offset，不过是针对targetNode的\r\n            };\r\n            domAlign(this.wrapperRef.el, triggerNode, alignConfig);\r\n        }\r\n    }\r\n\r\n    public setup(): void {\r\n        useImperativeHandle(() => ({\r\n            wrapperRef: this.wrapperRef,\r\n            align: this.align.bind(this)\r\n        }), () => []);\r\n\r\n        useEventListener(this.wrapperRef, 'animationend', (event) => {\r\n            // 动画完成后添加hiddenclass，使不占据dom空间\r\n            if (event.animationName === 'fadeout') {\r\n                this.wrapperRef.el?.classList.add(triggerHiddenClass);\r\n                // 如果设置了隐藏时销毁，在动画完成后移除dom\r\n                if (this.props.destroyOnHide) {\r\n                    this.state.isShow = false;\r\n                }\r\n            }\r\n        });\r\n\r\n        useEventListener(this.wrapperRef, 'scroll', (event) => {\r\n            this.props.onScroll?.(event);\r\n        });\r\n\r\n        useEffect(() => {\r\n            const { isOpen } = this.props;\r\n            if (isOpen) {\r\n                this.state.isShow = true;\r\n            }\r\n        }, () => [this.props.isOpen]);\r\n\r\n        useEffect(() => {\r\n            const { isOpen } = this.props;\r\n            this.lastIsOpen = isOpen;\r\n            if (isOpen) {\r\n                // 打开时先移除hidden的class，否则display: none不能触发动画\r\n                this.wrapperRef.el?.classList.remove(triggerHiddenClass);\r\n            }\r\n            this.align();\r\n        }, () => [this.wrapperRef.el, this.props.isOpen, this.props.triggerNode]);\r\n    }\r\n}\r\n\r\nexport default Trigger;\r\n","import { Component, useEffect, useRef, useState, xml } from '@odoo/owl';\r\nimport { BaseProps, baseProps } from '@/common/baseProps';\r\nimport classNames from 'classnames';\r\nimport { getPrefixCls, getSDSVG } from '@/components/_util/utils';\r\nimport './style/overflow.scss';\r\nimport { useSize } from '@/hooks/useSize';\r\nimport _closeSVG from '@/assets/close.svg';\r\nimport { isNumber } from '@/components/_util';\r\n\r\nconst closeSVG = getSDSVG(_closeSVG, {\r\n    width: '1em',\r\n    height: '1em'\r\n});\r\n\r\ntype Props = {\r\n    className?: string;\r\n    values: (string | number)[];\r\n    options: Option[];\r\n    maxTagCount?: number | 'responsive';\r\n    handleDelete?: (option: Option) => void;\r\n} & BaseProps;\r\n\r\nconst overflowClass = getPrefixCls('overflow');\r\nconst displayTagClass = `${overflowClass}-display-span-tag`;\r\n\r\nexport type Option = {\r\n    value: string | number;\r\n    label: string\r\n}\r\n\r\ntype State = {\r\n    displayMaxIndex: number;\r\n    displayOptions: Option[];  // 用于显示的option，不会包含overflow部分\r\n    rest?: number;\r\n};\r\n\r\nclass Overflow extends Component<Props> {\r\n    static props = {\r\n        className: { type: String, optional: true },\r\n        values: { type: Array },\r\n        options: { type: Array },\r\n        maxTagCount: { type: [Number, String], optional: true },\r\n        handleDelete: { type: Function, optional: true },\r\n        ...baseProps\r\n    };\r\n\r\n    static tagTemplate = (inner: string) => `\r\n<span t-att-class=\"classes.rest\">\r\n    <span class=\"${displayTagClass}-container\">\r\n        <span class=\"${displayTagClass}-label\">\r\n            ${inner}\r\n        </span>\r\n    </span>\r\n</span>\r\n`;\r\n\r\n    static displayTemplate = (hasEvent: boolean) => `\r\n<t t-slot=\"tag\" data=\"option\">\r\n    <span class=\"${displayTagClass}\">\r\n        <span class=\"${displayTagClass}-container\">\r\n            <span class=\"${displayTagClass}-label\">\r\n                <t t-esc=\"option.label\"/>\r\n            </span>\r\n            <span class=\"${displayTagClass}-icon\" ${hasEvent ?\r\n        't-on-click.stop=\"(event) => this.handleDelete(option)\"' : ''} >${closeSVG}</span>\r\n        </span>\r\n    </span>\r\n</t>\r\n`;\r\n\r\n    static template = xml`\r\n<t>\r\n    <t t-set=\"classes\" t-value=\"getClass()\"/>\r\n    <span t-ref=\"container\" t-att-class=\"classes.container\">\r\n        <t t-foreach=\"state.displayOptions\" t-as=\"option\" t-key=\"option.value\">\r\n            ${Overflow.displayTemplate(true)}\r\n        </t> \r\n        <t t-if=\"state.rest\" >\r\n            ${Overflow.tagTemplate(`<t t-esc=\"'+' + state.rest + '...'\"/>`)}\r\n        </t>\r\n        <span t-att-class=\"classes.suffix\" t-ref=\"suffix\">\r\n            <t t-slot=\"suffix\"/>\r\n        </span>\r\n        \r\n        <t t-if=\"props.maxTagCount !== undefined\">\r\n            <span t-ref=\"temp\" t-att-class=\"classes.temp\">\r\n                <t t-foreach=\"getWholeOptions()\" t-as=\"option\" t-key=\"option.value\">\r\n                    ${Overflow.displayTemplate(false)}\r\n                </t> \r\n            </span>\r\n            <span t-ref=\"overFlowTemp\" t-att-class=\"classes.temp\">\r\n                <t t-foreach=\"props.values\" t-as=\"value\" t-key=\"value_index\">\r\n                    ${Overflow.tagTemplate(`<t t-esc=\"'+' + (value_index + 1) + '...'\"/>`)}\r\n                </t> \r\n            </span>\r\n        </t>\r\n    </span>\r\n</t>\r\n`;\r\n\r\n    containerRef = useRef('container');\r\n\r\n    tempRef = useRef('temp');\r\n\r\n    overFlowTempRef = useRef('overFlowTemp');\r\n\r\n    containerSize = useSize('container');\r\n\r\n    suffixSize = useSize('suffix');\r\n\r\n    state = useState<State>({\r\n        displayMaxIndex: 0,  // 超出显示时用于显示的索引\r\n        displayOptions: [],  // 超出显示时用于显示的值\r\n        rest: undefined\r\n    });\r\n\r\n    protected getClass() {\r\n        return {\r\n            container: classNames(this.props.className, overflowClass, {\r\n                [`${overflowClass}-responsive`]: this.props.maxTagCount === 'responsive'\r\n            }),\r\n            temp: classNames(this.props.className, `${overflowClass}-temp`),\r\n            rest: classNames(displayTagClass, `${overflowClass}-rest`),\r\n            suffix: `${overflowClass}-suffix`\r\n        };\r\n    }\r\n\r\n    protected isOverflow(index: number, targetWidth: number, searchWidth: number): boolean {\r\n        const restIndex = Math.max(0, this.props.values.length - 1 - index);\r\n        const overFlowSpamWidth = this.overFlowTempRef.el?.children[restIndex].getBoundingClientRect().width || 0;\r\n        return targetWidth + overFlowSpamWidth + searchWidth >= this.containerSize.width!;\r\n    }\r\n\r\n    protected handleDelete(option: Option) {\r\n        this.props.handleDelete?.(option);\r\n    }\r\n\r\n    /**\r\n     * 所有应该显示的option，包含overflow部分\r\n     * @protected\r\n     */\r\n    protected getWholeOptions() {\r\n        const { values, options } = this.props;\r\n        return options.filter((c) => values.indexOf(c.value) !== -1);\r\n    }\r\n\r\n    public setup(): void {\r\n        useEffect(() => {\r\n            const { maxTagCount, values, options } = this.props;\r\n            if (isNumber(maxTagCount)) {\r\n                this.state.displayMaxIndex = maxTagCount;\r\n            } else if (maxTagCount === undefined) {\r\n                this.state.displayMaxIndex = Math.max(0, this.props.values.length);\r\n            } else if (this.tempRef.el && this.containerSize.width) {\r\n                // 获取所有子元素\r\n                const children = this.tempRef.el.children;\r\n                // 初始化总宽度\r\n                let totalWidth = 0;\r\n                this.state.displayMaxIndex = values.length;\r\n                for (let i = 0; i < values.length; i++) {\r\n                    // 获取子元素的宽度，不包括间隔和margin\r\n                    const childWidth = children[i].getBoundingClientRect().width;\r\n                    totalWidth += childWidth;\r\n                    let searchWidth = this.suffixSize.width || 0;\r\n                    // 如果超出或等于maxTagCount，跳出循环\r\n                    if (this.isOverflow(i, totalWidth, searchWidth)) {\r\n                        this.state.displayMaxIndex = i;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            const displayValues = values.slice(0, this.state.displayMaxIndex);\r\n            this.state.displayOptions = options.filter((c) => displayValues.indexOf(c.value) !== -1);\r\n            // 计算剩余显示部分\r\n            const restIndex = Math.max(0, this.props.values.length - this.state.displayMaxIndex);\r\n            this.state.rest = restIndex > 0 ? restIndex : undefined;\r\n        }, () => [\r\n            this.tempRef.el, this.containerSize.width, this.suffixSize.width, this.props.values, this.props.options\r\n        ]);\r\n    }\r\n}\r\n\r\nexport default Overflow;\r\n","import { Component, useEffect, useRef, useState, xml } from '@odoo/owl';\r\nimport { baseProps, BaseProps } from '@/common/baseProps';\r\nimport { getPrefixCls, getSDSVG, stylesToString } from '@/components/_util/utils';\r\nimport _downSVG from '@/assets/down.svg';\r\nimport _searchSVG from '@/assets/search.svg';\r\nimport _emptySVG from '@/assets/empty.svg';\r\nimport _loadingSVG from '@/assets/loading-line.svg';\r\nimport _checkSVG from '@/assets/check.svg';\r\nimport classNames from 'classnames';\r\nimport List from '@/components/list/List';\r\nimport Trigger, { Placement } from '@/components/trigger/trigger';\r\nimport './style/select.scss';\r\nimport { useEventListener } from '@/hooks/useEventListener';\r\nimport { useCompRef, useImperativeHandle } from '@/hooks/useImperativeHandle';\r\nimport useControllableState from '@/hooks/useControllableState';\r\nimport { useColsSearch } from '@/hooks/useColsSearch';\r\nimport { SizeType } from '@/components/_util/type';\r\nimport { useCancellableTimer } from '@/hooks/useCancellableTimer';\r\nimport { useResizeObserver } from '@/hooks/useSizeObserver';\r\nimport Overflow, { Option } from '@/components/select/Overflow';\r\nimport _closeSVG from '@/assets/close_fill.svg';\r\nimport { ItemHeight, Position } from '@/components/list/VirtualList';\r\n\r\nconst downSVG = getSDSVG(_downSVG, {\r\n    width: '1em',\r\n    height: '1em'\r\n});\r\n\r\nconst searchSVG = getSDSVG(_searchSVG, {\r\n    width: '1em',\r\n    height: '1em'\r\n});\r\n\r\nconst emptySVG = getSDSVG(_emptySVG, {\r\n    width: '64',\r\n    height: '41'\r\n});\r\n\r\nconst loadingSVG = getSDSVG(_loadingSVG, {\r\n    width: '1em',\r\n    height: '1em'\r\n});\r\n\r\nconst checkSVG = getSDSVG(_checkSVG, {\r\n    width: '1em',\r\n    height: '1em'\r\n});\r\n\r\nconst closeSVG = getSDSVG(_closeSVG, {\r\n    width: '1em',\r\n    height: '1em'\r\n});\r\n\r\ntype Value<T> = T | T[];\r\n\r\ntype Props = {\r\n    className?: string;\r\n    allowClear?: boolean;\r\n    autoClearSearchValue?: boolean;\r\n    getPopupContainer?: (triggerNode?: HTMLElement) => string; // 返回一个选择器字符串\r\n    placement?: Placement;\r\n    listHeight?: number;\r\n    disabled?: boolean;\r\n    multiple?: boolean;\r\n    value?: Value<string> | Value<number>;\r\n    defaultValue?: Value<string> | Value<number>;\r\n    size: SizeType,\r\n    placeholder?: string;\r\n    bordered?: boolean;\r\n    defaultOpen?: boolean;\r\n    autoFocus?: boolean;\r\n    popupClassName?: string;\r\n    popupMatchSelectWidth?: boolean;\r\n    showSearch?: boolean;\r\n    filterOption?: (searchValue: string, option: Option) => boolean;\r\n    filterSort?: (optionA: Option, optionB: Option) => number;\r\n    options: Option[];\r\n    loading?: boolean;\r\n    open?: boolean;\r\n    maxTagCount?: number | 'responsive';\r\n    virtual?: boolean;\r\n    itemHeight?: number | ItemHeight;\r\n    onSearch?: (value: string) => boolean;\r\n    onSelect?: (option: Option) => void;\r\n    onDeselect?: (option: Option) => void;\r\n    onClear?: () => void;\r\n    onDropdownVisibleChange?: (open: boolean) => void;\r\n    onFocus?: () => void;\r\n    onPopupScroll?: (event: MouseEvent, position?: Position) => void;\r\n} & BaseProps;\r\n\r\nconst selectClass = getPrefixCls('select');\r\nconst selectIconClass = getPrefixCls('select-icon');\r\nconst selectRotateIconClass = getPrefixCls('select-rotate-icon');\r\nconst selectSelectorClass = getPrefixCls('select-selector');\r\nconst selectDropdownClass = getPrefixCls('select-dropdown');\r\nconst dropdownEmptyClass = getPrefixCls('select-dropdown-empty');\r\nconst selectDropdownItemWrapperClass = getPrefixCls('select-dropdown-item-wrapper');\r\n// 需要额外包裹一层，因为item最外层有padding，点击事件到达不了，影响体验\r\nconst selectDropdownItemClass = getPrefixCls('select-dropdown-item');\r\nconst searchSpanClass = getPrefixCls('select-search-span');\r\nconst displaySpanClass = getPrefixCls('select-display-span');\r\n\r\ntype State = {\r\n    searchValue: string;\r\n    triggerNode?: HTMLElement;\r\n    focus: boolean;\r\n    multipleInputStyle?: string\r\n};\r\n\r\nclass Select extends Component<Props> {\r\n    static components = { List, Trigger, Overflow };\r\n\r\n    static props = {\r\n        className: { type: String, optional: true },\r\n        allowClear: { type: Boolean, optional: true },\r\n        autoClearSearchValue: { type: Boolean, optional: true },\r\n        getPopupContainer: { type: Function, optional: true },\r\n        placement: { type: String, optional: true },\r\n        listHeight: { type: Number, optional: true },\r\n        disabled: { type: Boolean, optional: true },\r\n        value: { type: [String, Array, Number], optional: true },\r\n        defaultValue: { type: [String, Array, Number], optional: true },\r\n        multiple: { type: Boolean, optional: true },\r\n        size: { type: String, optional: true },\r\n        placeholder: { type: String, optional: true },\r\n        bordered: { type: Boolean, optional: true },\r\n        defaultOpen: { type: Boolean, optional: true },\r\n        autoFocus: { type: Boolean, optional: true },\r\n        popupClassName: { type: String, optional: true },\r\n        popupMatchSelectWidth: { type: Boolean, optional: true },\r\n        showSearch: { type: Boolean, optional: true },\r\n        filterOption: { type: Function, optional: true },\r\n        filterSort: { type: Function, optional: true },\r\n        options: { type: Array },\r\n        loading: { type: Boolean, optional: true },\r\n        open: { type: Boolean, optional: true },\r\n        maxTagCount: { type: [Number, String], optional: true },\r\n        virtual: { type: Boolean, optional: true },\r\n        itemHeight: { type: [Number, Function], optional: true },\r\n        onSearch: { type: Function, optional: true },\r\n        onSelect: { type: Function, optional: true },\r\n        onDeselect: { type: Function, optional: true },\r\n        onClear: { type: Function, optional: true },\r\n        onDropdownVisibleChange: { type: Function, optional: true },\r\n        onFocus: { type: Function, optional: true },\r\n        onPopupScroll: { type: Function, optional: true },\r\n        ...baseProps\r\n    };\r\n\r\n    static defaultProps = {\r\n        autoClearSearchValue: true,\r\n        listHeight: 256,\r\n        virtual: false,\r\n        popupMatchSelectWidth: true,\r\n        multiple: false,\r\n        bordered: true,\r\n        placement: 'bottomLeft'\r\n    };\r\n\r\n    state = useState<State>({\r\n        searchValue: '',\r\n        focus: this.props.autoFocus || false,\r\n        triggerNode: undefined,\r\n        multipleInputStyle: undefined\r\n    });\r\n\r\n    controllableState = useControllableState<{ value?: Value<string> | Value<number>, open?: boolean }>(this.props, {\r\n        value: this.props.defaultValue ?? this.props.multiple ? [] : undefined,\r\n        open: false\r\n    });\r\n\r\n    colsState = useColsSearch(this.props.options, this.props.filterOption, this.props.filterSort);\r\n\r\n    cancelableTimer = useCancellableTimer();\r\n\r\n    containerRef = useRef('container');\r\n\r\n    searchTempRef = useRef('searchTemp');\r\n\r\n    searchSpanRef = useRef('searchSpan');\r\n\r\n    searchRef = useRef('search');\r\n\r\n    triggerRef = useCompRef();\r\n\r\n    static template = xml`\r\n<span t-ref=\"container\" t-att-class=\"getClass()\" t-on-click=\"onClickContainer\">\r\n    <span class=\"${selectSelectorClass}\">\r\n        <span t-if=\"showPlaceholder()\" class=\"${selectSelectorClass}-placeholder\"><t t-esc=\"props.placeholder\"/></span>\r\n        <div class=\"${selectSelectorClass}-temp\" t-ref=\"searchTemp\"><t t-esc=\"state.searchValue\"/></div>\r\n        <t t-set=\"searchClass\" t-value=\"getSearchClass()\"/>\r\n        <t t-if=\"props.multiple\">\r\n            <Overflow slots=\"props.slots\" className=\"'${selectSelectorClass}-tags'\" values=\"controllableState.state.value\" maxTagCount=\"props.maxTagCount\" options=\"props.options\" handleDelete.bind=\"handleDeleteChoice\">\r\n                <t t-set-slot=\"suffix\">\r\n                    <t t-if=\"props.showSearch\">\r\n                        <span t-att-class=\"searchClass.search\">\r\n                            <span t-ref=\"searchSpan\">\r\n                                <input t-ref=\"search\" t-on-input=\"onInput\" t-att-value=\"state.searchValue\" type=\"text\"/>\r\n                            </span>\r\n                        </span>\r\n                    </t>\r\n                </t>\r\n            </Overflow>\r\n        </t>\r\n        <t t-else=\"\">\r\n            <t t-if=\"props.showSearch\">\r\n                <span t-att-class=\"searchClass.search\"><input t-on-input=\"onInput\" t-att-value=\"state.searchValue\" type=\"text\"/></span>\r\n            </t>\r\n            <t t-set=\"displayOption\" t-value=\"getOption(controllableState.state.value)\"/>\r\n            <span t-if=\"displayOption\" t-att-class=\"searchClass.display\">\r\n                <t t-slot=\"label\" data=\"displayOption\">\r\n                    <t t-esc=\"displayOption.label\"/>\r\n                </t>\r\n            </span>\r\n        </t>\r\n    </span>\r\n    <Trigger ref=\"triggerRef\" onScroll.bind=\"onScroll\" className=\"getPopupClass()\" isOpen=\"controllableState.state.open\" triggerNode=\"state.triggerNode\" \r\n        getPopupContainer=\"props.getPopupContainer\" getStyle.bind=\"getDropdownStyle\" placement=\"props.placement\">\r\n        <t t-if=\"colsState.state.displayCols.length === 0\">\r\n            <t t-slot=\"empty\">\r\n                <div class=\"${dropdownEmptyClass}\">\r\n                    <div>${emptySVG}</div>\r\n                    <div>暂无数据</div>\r\n                </div>\r\n            </t>\r\n        </t>\r\n        <t t-else=\"\">\r\n            <List dataSource=\"colsState.state.displayCols\" itemClassName.bind=\"getItemClass\" virtual=\"props.virtual\" itemHeight=\"props.itemHeight\" height=\"props.listHeight\" onScroll.bind=\"onScroll\">\r\n                <t t-set-slot=\"item\" t-slot-scope=\"scope\">\r\n                    <div class=\"${selectDropdownItemClass}\" t-on-click.synthetic=\"() => this.handleChoice(scope.data)\">\r\n                        <span>\r\n                            <t t-slot=\"label\" data=\"scope.data\">\r\n                                <t t-esc=\"scope.data.label\"/>\r\n                            </t>\r\n                        </span>\r\n                        <span class=\"${selectDropdownItemClass}-icon\" t-if=\"this.showSelectedSuffix(scope.data)\">${checkSVG}</span>\r\n                    </div>\r\n                </t>\r\n            </List>        \r\n        </t>\r\n    </Trigger>\r\n    <span class=\"${selectIconClass}\">\r\n        <t t-if=\"props.loading\"><span class=\"${selectRotateIconClass}\">${loadingSVG}</span></t>\r\n        <t t-elif=\"state.searchValue\">${searchSVG}</t>\r\n        <t t-else=\"\">${downSVG}</t>\r\n        \r\n        <span t-if=\"!props.disabled &amp;&amp; props.allowClear\" class=\"${selectIconClass}-clear\" t-on-click=\"handleClear\">\r\n            ${closeSVG}\r\n        </span>\r\n    </span>\r\n </span>   \r\n    `;\r\n\r\n    /**\r\n     * 判断是否显示placeholder的逻辑\r\n     * @protected\r\n     */\r\n    protected showPlaceholder() {\r\n        const { multiple } = this.props;\r\n        if (!!this.state.searchValue) {\r\n            return false;\r\n        }\r\n\r\n        if (!multiple) {\r\n            return !this.controllableState.state.value;\r\n        }\r\n        return (this.controllableState.state.value as (string | number)[]).length === 0;\r\n    }\r\n\r\n    /**\r\n     * 搜索值变化时触发回调\r\n     * @param event\r\n     * @protected\r\n     */\r\n    protected onInput(event: Event) {\r\n        const value = (event.currentTarget as HTMLInputElement).value;\r\n        this.state.searchValue = value;\r\n        this.colsState.state.searchValue = value;\r\n        this.props.onSearch?.(value);\r\n    }\r\n\r\n    /**\r\n     * 清空搜索值\r\n     * @protected\r\n     */\r\n    protected clear() {\r\n        this.state.searchValue = '';\r\n        this.colsState.state.searchValue = '';\r\n    }\r\n\r\n    /**\r\n     * 延时清空搜索值，但是会马上清空显示的值\r\n     * @protected\r\n     */\r\n    protected timerClear() {\r\n        // 先清空searchValue使展示正常\r\n        this.state.searchValue = '';\r\n        this.cancelableTimer.run(this.clear.bind(this), 1000);\r\n    }\r\n\r\n    /**\r\n     * 点击最外层容器时触发的回调\r\n     * @param event\r\n     * @protected\r\n     */\r\n    protected onClickContainer(event: MouseEvent) {\r\n        if (!this.props.disabled) {\r\n            // 打开时如果有searchRef，则进行聚焦，仅multiple有用\r\n            this.searchRef.el?.focus();\r\n            // 如果已经open并且允许search，则不进行关闭\r\n            if (this.controllableState.state.open && this.props.showSearch) {\r\n                return;\r\n            }\r\n            this.toggleOpen();\r\n            this.state.focus = true;\r\n            this.props.onFocus?.();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 下拉框的显示状态改变时触发\r\n     * @param open 是否显示\r\n     * @protected\r\n     */\r\n    protected onDropdownVisibleChange(open: boolean) {\r\n        this.controllableState.setState({\r\n            open\r\n        });\r\n        this.props.onDropdownVisibleChange?.(open);\r\n    }\r\n\r\n    /**\r\n     * 切换下拉框的显示状态\r\n     * @param force 切换状态\r\n     * @protected\r\n     */\r\n    protected toggleOpen(force?: boolean) {\r\n        if (!this.props.disabled) {\r\n            this.onDropdownVisibleChange(force ?? !this.controllableState.state.open);\r\n            if (this.controllableState.state.open) {\r\n                this.clear();\r\n                this.cancelableTimer.cancel();\r\n                this.state.triggerNode = this.containerRef.el!;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * select组件的样式类\r\n     * @protected\r\n     */\r\n    protected getClass() {\r\n        const { size, className, disabled, bordered } = this.props;\r\n\r\n        return classNames(className, selectClass, {\r\n            [`${selectClass}-borderless`]: !bordered,\r\n            [`${selectClass}-focus`]: this.state.focus,\r\n            [`${selectClass}-multiple`]: !!this.props.multiple,\r\n            [`${selectClass}-isOpen`]: this.controllableState.state.open,\r\n            [`${selectClass}-searchable`]: this.props.showSearch,\r\n            [`${selectClass}-disabled`]: !!disabled,\r\n            [`${selectClass}-sm`]: size === 'small',\r\n            [`${selectClass}-lg`]: size === 'large',\r\n            [`${selectClass}-vir`]: false\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 搜索相关部分的样式\r\n     * @protected\r\n     */\r\n    protected getSearchClass() {\r\n        return {\r\n            search: classNames(searchSpanClass, {\r\n                [`${searchSpanClass}-multiple`]: !!this.props.multiple\r\n            }),\r\n            display: classNames(displaySpanClass, {\r\n                [`${selectClass}-v-hidden`]: !this.props.multiple && !!this.state.searchValue  // 多选模式下不隐藏\r\n            })\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 下拉框的class\r\n     * @protected\r\n     */\r\n    protected getPopupClass() {\r\n        return classNames(selectDropdownClass, this.props.popupClassName, {\r\n            [`${selectDropdownClass}-virtual`]: !!this.props.virtual\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 选项的样式类\r\n     * @param item\r\n     * @param index\r\n     * @protected\r\n     */\r\n    protected getItemClass(item: Option, index: number) {\r\n        if (!this.props.multiple) {\r\n            return classNames(selectDropdownItemWrapperClass, {\r\n                [`${selectDropdownItemClass}-selected`]: item.value === this.controllableState.state.value\r\n            });\r\n        }\r\n\r\n        return classNames(selectDropdownItemWrapperClass, {\r\n            [`${selectDropdownItemClass}-selected`]: (this.controllableState.state.value as (string | number)[]).indexOf(\r\n                item.value) !== -1\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 下拉框的样式style\r\n     * @param triggerNode\r\n     * @protected\r\n     */\r\n    protected getDropdownStyle(triggerNode?: HTMLElement) {\r\n        if (!triggerNode) {\r\n            return;\r\n        }\r\n\r\n        const { clientWidth } = triggerNode;\r\n        const style = {\r\n            'max-height': `${this.props.listHeight}px`\r\n        };\r\n        if (this.props.popupMatchSelectWidth) {\r\n            style['width'] = `${clientWidth}px`;\r\n        }\r\n\r\n        return stylesToString(style);\r\n    }\r\n\r\n    /**\r\n     * 判断下拉框中是否显示已选的后缀标识\r\n     * @param option 选项\r\n     * @protected\r\n     */\r\n    protected showSelectedSuffix(option: Option) {\r\n        return this.props.multiple && (this.controllableState.state.value as (string | number)[]).indexOf(\r\n            option.value) !== -1;\r\n    }\r\n\r\n    /**\r\n     * 点击外部区域时，关闭下拉框\r\n     * @param event\r\n     * @protected\r\n     */\r\n    protected onClickOutsideHandler(event: MouseEvent) {\r\n        const target = event.target as HTMLElement;\r\n        // 在点击非选择框区域和非选项区域时，关闭下拉框\r\n        if (!this.containerRef.el?.contains(target) && !this.triggerRef.current?.wrapperRef.el?.contains(target)) {\r\n            if (this.controllableState.state.open) {\r\n                this.toggleOpen(false);\r\n            }\r\n            this.state.focus = false;\r\n            this.timerClear();\r\n        }\r\n    }\r\n\r\n    protected onScroll(event: MouseEvent, position?: Position) {\r\n        this.props.onPopupScroll?.(event, position);\r\n    }\r\n\r\n    /**\r\n     * 清空选项的回调\r\n     * @param event\r\n     * @protected\r\n     */\r\n    protected handleClear(event: MouseEvent) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        this.controllableState.setState({\r\n            value: this.props.multiple ? [] : undefined\r\n        });\r\n        this.props.onClear?.();\r\n    }\r\n\r\n    /**\r\n     * 选中下拉选项的回调\r\n     * @param option\r\n     * @protected\r\n     */\r\n    protected handleChoice(option: Option) {\r\n        if (this.props.multiple) {\r\n            const { value } = option;\r\n            const stateValue = [...this.controllableState.state.value as any[]];\r\n            const index = stateValue.indexOf(value);\r\n            if (index === -1) {\r\n                // 新选中\r\n                stateValue.push(value);\r\n                this.controllableState.setState({\r\n                    value: stateValue\r\n                });\r\n                this.props.onSelect?.(option);\r\n            } else {\r\n                // 取消选中\r\n                this.handleDeleteChoice(option)\r\n            }\r\n\r\n        }else {\r\n            this.controllableState.setState({\r\n                value: option.value\r\n            });\r\n            this.props.onSelect?.(option);\r\n        }\r\n\r\n        if (!this.props.multiple) {\r\n            this.timerClear();\r\n            this.onDropdownVisibleChange(false);\r\n        } else if (this.props.autoClearSearchValue) {\r\n            this.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 取消选中值的回调\r\n     * @param option\r\n     * @protected\r\n     */\r\n    protected handleDeleteChoice(option: Option) {\r\n        const filterValues = (this.controllableState.state.value as any[]).filter((v) => v !== option.value);\r\n        this.controllableState.setState({\r\n            value: filterValues\r\n        });\r\n        this.props.onDeselect?.(option);\r\n    }\r\n\r\n    /**\r\n     * 根据value值获取对应的option\r\n     * @param value\r\n     * @protected\r\n     */\r\n    protected getOption(value: string | number) {\r\n        return this.props.options.find((c) => c.value === value);\r\n    }\r\n\r\n    public setup(): void {\r\n        const target = { el: window };\r\n        useImperativeHandle(() => ({\r\n            focus: () => {\r\n                this.state.focus = true;\r\n                this.props.onFocus?.();\r\n            },\r\n            blur: () => {\r\n                this.state.focus = false;\r\n            }\r\n        }), () => [])\r\n\r\n        useEventListener(target, 'mousedown', this.onClickOutsideHandler);\r\n\r\n        // 监听尺寸变化，如果是打开状态并且尺寸发生了变化，则进行对齐，使用ResizeObserver节约性能开销\r\n        useResizeObserver(this.containerRef, (entry) => {\r\n            if (this.controllableState.state.open) {\r\n                this.triggerRef.current?.align();\r\n            }\r\n        });\r\n\r\n        useEffect(() => {\r\n            this.colsState.state.columns = this.props.options;\r\n        }, () => [this.props.options]);\r\n\r\n        // 是否默认展开逻辑\r\n        useEffect(() => {\r\n            if (this.props.defaultOpen && !this.props.disabled) {\r\n                this.state.triggerNode = this.containerRef.el!;\r\n                this.onDropdownVisibleChange(true);\r\n            }\r\n            // 初始有焦点时触发一次onFocus事件\r\n            if (this.props.autoFocus) {\r\n                this.props.onFocus?.();\r\n            }\r\n        }, () => []);\r\n\r\n        // 在输入框宽度不足时进行适配换行处理\r\n        useEffect(() => {\r\n            if (!this.searchSpanRef.el) {\r\n                return;\r\n            }\r\n\r\n            let width = '4px';\r\n            if (this.state.searchValue) {\r\n                width = getComputedStyle(this.searchTempRef.el!).width;\r\n            }\r\n            this.searchSpanRef.el.style.width = width;\r\n        }, () => [this.state.searchValue, this.searchSpanRef.el]);\r\n    }\r\n}\r\n\r\nexport default Select;\r\n"],"names":[],"sourceRoot":""}